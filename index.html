<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scorebook</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0f2f7; /* Lighter blue-gray background for a fresh feel */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to start for better scrolling on small screens */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        /* Container for the app to center it on larger screens and provide padding */
        .app-container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15); /* More pronounced shadow */
            padding: 2.5rem; /* Increased padding */
            width: 100%;
            max-width: 950px; /* Slightly increased max width */
            margin-top: 20px; /* Space from top */
        }
        /* Style for form labels */
        label {
            display: block;
            margin-bottom: 0.6rem; /* Slightly more space */
            font-weight: 600;
            color: #2d3748; /* Darker text for labels */
        }
        /* Style for input fields, textareas, and selects */
        input[type="text"],
        input[type="number"],
        input[type="date"], /* Added style for date input */
        input[type="time"], /* Added style for time input */
        textarea,
        select {
            width: 100%;
            padding: 0.75rem 1.5rem; /* Reduced padding for smaller inputs */
            margin-bottom: 1rem; /* Reduced space below inputs */
            border: 1px solid #cbd5e1; /* Light gray border */
            border-radius: 0.75rem; /* More rounded corners for inputs */
            font-size: 0.95rem; /* Slightly smaller font size for readability */
            box-sizing: border-box; /* Include padding in width */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            text-align: center; /* Center align text in input boxes */
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus, /* Added focus style for date input */
        input[type="time"]:focus, /* Added focus style for time input */
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #3b82f6; /* Blue border on focus */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); /* Blue ring on focus */
        }
        /* Style for buttons - now unified */
        button {
            background-color: #87CEEB; /* Solid Light blue background (SkyBlue) */
            color: #1a202c; /* Black text */
            padding: 0.6rem 1.2rem; /* Reduced default padding for a more balanced look */
            border-radius: 0.5rem; /* Equivalent to rounded-lg */
            font-weight: 700; /* Bold */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Equivalent to shadow-lg */
            border: 1px solid #6495ED; /* Subtle border matching a slightly darker light blue */
            box-sizing: border-box; /* Ensure padding is included in element's total width and height */
            /* These properties center the *content* inside the button */
            display: flex;
            justify-content: center;
            align-items: center;
            white-space: nowrap; /* Prevent text from wrapping */
            /* Removed margin: 0 auto; from here, as parent flex will handle centering */
        }
        button:hover {
            background-color: #6495ED; /* Slightly darker light blue on hover */
            transform: translateY(-1px);
            box-shadow: 0 15px 20px -5px rgba(0, 0, 0, 0.15), 0 6px 8px -3px rgba(0, 0, 0, 0.08); /* Slightly more pronounced shadow on hover */
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:disabled {
            background-color: #e2e8f0; /* Lighter gray out disabled buttons */
            color: #94a3b8; /* Lighter text for disabled */
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
            border-color: #cbd5e1; /* Match border to background */
        }
        /* Specific padding for larger primary action buttons */
        #teamRegistrationForm button[type="submit"],
        #proceedToMatchReadyBtn,
        #startMatchBtn,
        #newMatchBtn,
        #clearPastMatchesBtn,
        #backToMainBtn,
        #endMatchBtn,
        #showDeveloperInfoBtn {
            padding: 0.8rem 2rem; /* Slightly larger padding for main action buttons */
            font-size: 0.9rem; /* Slightly larger font for main action buttons */
        }

        /* Ensure score control buttons maintain their size or inherit the new default */
        .score-control-button {
            padding: 0.5rem 1rem; /* Slightly smaller padding for score controls */
        }

        /* Message box styling */
        .message-box {
            position: fixed;
            top: 20px; /* Distance from top */
            right: 20px; /* Distance from right */
            transform: translateX(100%); /* Start off-screen to the right */
            background-color: #10b981; /* Green for success */
            color: white;
            padding: 1.2rem 2.5rem; /* More padding */
            border-radius: 1rem; /* More rounded */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25); /* Stronger shadow */
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
            text-align: center;
            font-size: 1.1rem; /* Slightly larger font */
            font-weight: 500;
        }
        .message-box.show {
            opacity: 1;
            transform: translateX(0) scale(1); /* Slide in from right */
        }
        .message-box.error {
            background-color: #ef4444; /* Red for error */
        }
        /* Scoreboard specific styles */
        .team-score-card {
            background-color: #f8fafc; /* Lighter background */
            border-radius: 1rem;
            padding: 1.8rem; /* More padding */
            text-align: center;
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.08); /* More subtle inner shadow */
            transition: all 0.3s ease-in-out;
        }
        .team-score-card.active {
            border: 3px solid #3b82f6; /* Thicker, more prominent highlight */
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.6); /* Stronger glow */
            background-color: #e3f2fd; /* Very light blue for active card */
        }
        .team-score-card h3 {
            font-size: 2rem; /* Larger team name */
            font-weight: 800; /* Extra bold */
            color: #1a202c; /* Darker text */
            margin-bottom: 0.8rem;
        }
        .team-score-card p {
            font-size: 1.35rem; /* Slightly larger paragraph text */
            color: #4a5568;
            margin-bottom: 0.6rem;
        }
        .score-display {
            font-size: 4rem; /* Significantly larger score */
            font-weight: 900;
            color: #1a202c;
            line-height: 1;
        }
        .overs-display {
            font-size: 1.8rem; /* Larger overs display */
            font-weight: 700;
            color: #4a5568;
        }
        .match-result {
            margin-top: 2.5rem;
            padding: 1.8rem;
            background-color: #d1fae5; /* Light green for success */
            border-radius: 1rem;
            border: 1px solid #34d399;
            text-align: center;
            font-size: 1.75rem; /* Larger result text */
            font-weight: bold;
            color: #065f46;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .match-result.draw {
            background-color: #bfdbfe; /* Light blue for draw */
            border-color: #60a5fa;
            color: #1e40af;
        }
        /* Table styles for scorecards */
        .scorecard-table {
            width: 100%;
            border-collapse: separate; /* Use separate to allow border-radius on cells */
            border-spacing: 0; /* Remove spacing between cells */
            margin-top: 1.8rem;
            font-size: 0.95rem;
            border-radius: 0.75rem; /* Rounded corners for the whole table */
            overflow: hidden; /* Hide overflowing borders */
        }
        .scorecard-table th, .scorecard-table td {
            border: 1px solid #e2e8f0; /* Lighter border */
            padding: 0.8rem 1rem; /* More padding */
            text-align: left;
        }
        .scorecard-table th {
            background-color: #e2e8f0; /* Light gray header */
            font-weight: 700;
            color: #4a5568;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .scorecard-table tbody tr:nth-child(odd) {
            background-color: #f7fafc; /* Very light alternating rows */
        }
        .scorecard-table tbody tr:hover {
            background-color: #ebf8ff; /* Light blue on hover */
        }
        .scorecard-table td.text-right {
            text-align: right;
        }
        .fall-of-wickets-list {
            list-style: none;
            padding: 0;
            max-height: 180px; /* Slightly taller */
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.2rem;
            background-color: #f7fafc;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        .fall-of-wickets-list li {
            padding: 0.6rem 0;
            border-bottom: 1px dashed #e2e8f0;
            color: #4a5568;
            word-break: break-word; /* Ensure text wraps within the list item */
            overflow-wrap: break-word; /* Modern equivalent for word-break */
        }
        .fall-of-wickets-list li:last-child {
            border-bottom: none;
        }
        .man-of-the-match {
            margin-top: 2.5rem;
            padding: 1.8rem;
            background-color: #fffacd; /* Light goldenrod yellow */
            border-radius: 1rem;
            border: 1px solid #fcd34d;
            text-align: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #b45309;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }
        /* Style for past matches section */
        .past-matches-section {
            margin-top: 2.5rem;
            padding: 2rem;
            background-color: #e3f2fd; /* Light blue background */
            border-radius: 1rem;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }
        .past-matches-list {
            list-style: none;
            padding: 0;
        }
        .past-matches-list li {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            min-width: 0; /* Allow shrinking */
        }
        .past-matches-list li:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.12);
        }
        .past-matches-list li h4,
        .past-matches-list li p {
            word-break: break-word;
            overflow-wrap: break-word; /* Modern equivalent */
        }
        .past-match-details {
            display: flex; /* Default to flex column for small screens */
            flex-direction: column;
            gap: 1.5rem; /* Increased gap */
            margin-top: 1.5rem;
        }
        @media (min-width: 768px) { /* md breakpoint in Tailwind */
            .past-match-details {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            }
        }
        .past-match-details .card {
            background-color: #f8fafc;
            border: 1px solid #cbd5e1;
            border-radius: 0.75rem;
            padding: 1.2rem;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            min-width: 0; /* Allow shrinking */
        }
        .past-match-details h5 {
            font-weight: bold;
            margin-bottom: 0.6rem;
            color: #2d3748;
        }
        .past-match-details table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.75rem;
        }
        .past-match-details th, .past-match-details td {
            border: 1px solid #e2e8f0;
            padding: 0.6rem;
            text-align: left;
            font-size: 0.9rem;
        }
        .past-match-details th {
            background-color: #edf2f7;
        }
        .app-logo {
            display: block;
            margin: 0 auto 1.8rem auto; /* Center the logo and add more margin below */
            width: 60px; /* Reduced logo size */
            height: 60px; /* Reduced logo size */
            color: #3b82f6; /* Blue color for the logo */
        }
        /* New styles for team registration form */
        #teamRegistrationSection {
            background-color: #f0f8ff; /* Very light blue background */
            border: 1px solid #e0e7ff; /* Subtle border */
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #teamRegistrationSection h2 {
            font-size: 2.2rem; /* Larger title for emphasis */
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
            text-align: center; /* Center the title */
        }
        #teamRegistrationForm .space-y-4 > div {
            margin-bottom: 1rem; /* Adjust spacing between form groups */
        }

        /* Styles for the new live score panel */
        .live-score-panel {
            background-color: #f8fafc;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 2rem;
        }

        .score-control-group {
            background-color: #edf2f7;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
        }
        .score-control-group h4 {
            font-weight: 700;
            color: #4a5568;
            margin-bottom: 0.75rem;
            text-align: center;
        }
        .info-panel {
            background-color: #ecfdf5; /* Light green for info */
            border: 1px solid #a7f3d0;
            border-radius: 0.75rem;
            padding: 1rem;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            color: #065f46;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        /* Developer Info Section Specific Styles */
        #developerInfoSection {
            background-color: #f0f8ff;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            text-align: center;
        }
        #developerInfoSection h2 {
            font-size: 2.2rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
        }
        #developerInfoSection p {
            font-size: 1.1rem;
            color: #4a5568;
            margin-bottom: 0.8rem;
        }
        #developerInfoSection .back-button {
            background-color: #87CEEB; /* Solid Light blue background (SkyBlue) */
            border: 1px solid #6495ED; /* Subtle border matching a slightly darker light blue */
            margin-top: 2rem;
        }

        /* Styles for the new Toss Section */
        #tossSection {
            background-color: #f0f8ff;
            border: 1px solid #e0e7ff;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #tossSection h2 {
            font-size: 2.2rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        #tossSection .space-y-4 > div {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Logo -->
        <div class="text-center mb-6">
            <svg class="app-logo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 2v10"></path>
                <path d="M12 12l4 4"></path>
                <path d="M12 12l-4 4"></path>
                <line x1="12" y1="2" x2="12" y2="22"></line>
                <line x1="2" y1="12" x2="22" y2="12"></line>
            </svg>
        </div>

        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Scorebook</h1>

        <!-- Team Registration Section -->
        <div id="teamRegistrationSection">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Team Registration</h2>
            <form id="teamRegistrationForm" class="space-y-4">
                <div>
                    <label for="team1Name">Team 1 Name:</label>
                    <input type="text" id="team1Name" name="team1Name" placeholder="e.g., Lions" required>
                </div>
                <div>
                    <label for="team1Players">Team 1 Players (one per line):</label>
                    <textarea id="team1Players" name="team1Players" rows="4" placeholder="Player A&#10;Player B&#10;Player C"></textarea>
                </div>

                <div class="mt-8">
                    <label for="team2Name">Team 2 Name:</label>
                    <input type="text" id="team2Name" name="team2Name" placeholder="e.g., Tigers" required>
                </div>
                <div>
                    <label for="team2Players">Team 2 Players (one per line):</label>
                    <textarea id="team2Players" name="team2Players" rows="4" placeholder="Player X&#10;Player Y&#10;Player Z"></textarea>
                </div>

                <div class="mt-8">
                    <label for="totalOvers">Total Overs per Innings:</label>
                    <input type="number" id="totalOvers" name="totalOvers" placeholder="e.g., 20" min="1" required>
                </div>

                <div class="mt-8">
                    <label for="matchDate">Match Date:</label>
                    <input type="date" id="matchDate" name="matchDate" required>
                </div>
                <div class="mt-8">
                    <label for="matchTime">Match Time:</label>
                    <input type="time" id="matchTime" name="matchTime" required>
                </div>

                <div class="flex justify-center"> <!-- Changed from text-center to flex justify-center -->
                    <button type="submit">Register Teams</button>
                </div>
            </form>
        </div>

        <!-- Toss Section (NEW - initially hidden) -->
        <div id="tossSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Match Toss</h2>
            <div class="space-y-4">
                <div>
                    <label for="tossWinner">Who won the toss?</label>
                    <select id="tossWinner" required>
                        <option value="">Select Winning Team</option>
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <label for="tossDecision">Decision:</label>
                    <select id="tossDecision" required>
                        <option value="">Select Decision</option>
                        <option value="bat">Bat First</option>
                        <option value="bowl">Bowl First</option>
                    </select>
                </div>
                <div class="flex justify-center"> <!-- Changed from text-center to flex justify-center -->
                    <button id="proceedToMatchReadyBtn">Proceed to Match Ready</button>
                </div>
            </div>
        </div>

        <!-- Match Ready Section (initially hidden) -->
        <div id="matchReadySection" class="hidden bg-blue-50 p-6 rounded-lg shadow-md text-center mt-8">
            <h2 class="text-xl font-semibold text-blue-800 mb-4">Match Ready!</h2>
            <p id="registeredTeamsSummary" class="text-lg text-blue-700 mb-6"></p>
            <div class="flex justify-center"> <!-- Added flex justify-center to center the button -->
                <button id="startMatchBtn">Start Match</button>
            </div>
        </div>

        <!-- Scoreboard Section (initially hidden) -->
        <div id="scoreboardSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">Live Score</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <!-- Team 1 Score Card -->
                <div id="team1Card" class="team-score-card">
                    <h3 id="displayTeam1Name">Team 1</h3>
                    <p class="score-display"><span id="team1Runs">0</span>/<span id="team1Wickets">0</span></p>
                    <p class="overs-display">Overs: <span id="team1Overs">0.0</span></p>
                    <p class="text-sm text-gray-500">Extras: <span id="team1Extras">0</span></p>
                </div>

                <!-- Team 2 Score Card -->
                <div id="team2Card" class="team-score-card">
                    <h3 id="displayTeam2Name">Team 2</h3>
                    <p class="score-display"><span id="team2Runs">0</span>/<span id="team2Wickets">0</span></p>
                    <p class="overs-display">Overs: <span id="team2Overs">0.0</span></p>
                    <p class="text-sm text-gray-500">Extras: <span id="team2Extras">0</span></p>
                </div>
            </div>

            <div class="mb-6 text-center">
                <p class="text-xl font-bold text-gray-800" id="currentBattingTeamContainer">Current Batting: <span id="currentBattingTeam"></span></p>
                <p class="text-lg text-gray-600" id="oversRemainingContainer">Overs Remaining: <span id="oversRemaining">N/A</span></p>
                <p class="text-lg text-gray-600" id="tossInfoDisplay">Toss: <span id="tossWinnerInfo"></span> won the toss and chose to <span id="tossDecisionInfo"></span> first.</p> <!-- NEW TOSS INFO DISPLAY -->
                <p class="text-lg text-gray-600 hidden" id="targetScoreDisplay">Target: <span id="targetScore">0</span> runs</p>
                <p class="text-lg font-bold text-red-600 mt-2 hidden" id="freeHitDisplay">FREE HIT!</p>

                <!-- NEW: Runs, Balls, Wickets Remaining for Chasing Team -->
                <div id="chasingInfoDisplay" class="hidden mt-4 text-lg text-gray-700">
                    <p><span id="runsRequired">0</span> runs needed from <span id="ballsRemaining">0</span> balls with <span id="wicketsRemaining">0</span> wickets remaining.</p>
                </div>
            </div>

            <!-- New Live Score Panel for controls and info -->
            <div class="live-score-panel">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <!-- Current Over and Partnership Info -->
                    <div class="info-panel" id="currentOverInfoPanel">
                        Current Over: <span id="currentOverBallsDisplay">0</span> balls
                    </div>
                    <div class="info-panel" id="partnershipInfoPanel">
                        Partnership: <span id="partnershipRunsDisplay">0</span> runs
                    </div>
                </div>

                <!-- Player Selection Dropdowns -->
                <div id="playerSelection" class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                    <div>
                        <label for="strikerSelect">Striker:</label>
                        <select id="strikerSelect"></select>
                    </div>
                    <div>
                        <label for="nonStrikerSelect">Non-Striker:</label>
                        <select id="nonStrikerSelect"></select>
                    </div>
                    <div>
                        <label for="bowlerSelect">Current Bowler:</label>
                        <select id="bowlerSelect"></select>
                    </div>
                </div>

                <!-- Score Control Buttons -->
                <div id="scoreControls" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Runs Group -->
                    <div class="score-control-group">
                        <h4>Runs</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="add1RunBtn" class="score-control-button">1 Run</button>
                            <button id="add2RunsBtn" class="score-control-button">2 Runs</button>
                            <button id="add4RunsBtn" class="score-control-button">4 Runs</button>
                            <button id="add6RunsBtn" class="score-control-button">6 Runs</button>
                        </div>
                    </div>

                    <!-- Wickets & Balls Group -->
                    <div class="score-control-group">
                        <h4>Wickets</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="addCaughtBtn" class="score-control-button">Caught</button>
                            <button id="addBowledLbwBtn" class="score-control-button">Bowled/LBW</button>
                            <button id="addRunOutBtn" class="score-control-button">Run Out</button>
                            <button id="addStumpedBtn" class="score-control-button">Stumped</button>
                            <button id="addHitWicketBtn" class="score-control-button">Hit Wicket</button>
                            <button id="addOtherWicketBtn" class="score-control-button">Other Wicket</button>
                        </div>
                    </div>

                    <!-- Extras Group -->
                    <div class="score-control-group">
                        <h4>Extras & Balls</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="addWideBtn" class="score-control-button">Wide</button>
                            <button id="addNoBallBtn" class="score-control-button">No Ball</button>
                            <button id="addByeBtn" class="score-control-button">Bye</button>
                            <button id="addLegByeBtn" class="score-control-button">Leg Bye</button>
                            <button id="addBallBtn" class="score-control-button">Dot Ball</button>
                        </div>
                    </div>

                    <!-- Utility Controls (full width on smaller screens) -->
                    <div class="score-control-group md:col-span-2 lg:col-span-3">
                        <h4>Match Controls</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="switchStrikeBtn" class="score-control-button">Switch Strike</button>
                            <button id="undoBtn" class="score-control-button">Undo Last</button>
                            <button id="switchTeamBtn" class="score-control-button">Switch Batting Team</button>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Scorecards Section (Live) -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-8" id="liveScorecards">
                <!-- Batsman Scorecard (Live) -->
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Batsman Scorecard (<span id="batsmanScorecardTeamName"></span>)</h3>
                    <div class="overflow-x-auto">
                        <table id="batsmanScorecard" class="scorecard-table">
                            <thead>
                                <tr>
                                    <th>Batsman</th>
                                    <th class="text-right">Runs</th>
                                    <th class="text-right">Balls</th>
                                    <th class="text-right">SR</th> <!-- Added Strike Rate header -->
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Batsman rows will be inserted here by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Bowler Scorecard (Live) -->
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Bowler Scorecard (<span id="bowlerScorecardTeamName"></span>)</h3>
                    <div class="overflow-x-auto">
                        <table id="bowlerScorecard" class="scorecard-table">
                            <thead>
                                <tr>
                                    <th>Bowler</th>
                                    <th class="text-right">Overs</th>
                                    <th class="text-right">Runs</th>
                                    <th class="text-right">Wickets</th>
                                    <th class="text-right">WD</th>
                                    <th class="text-right">NB</th>
                                    <th class="text-right">Econ</th> <!-- Added Economy header -->
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Bowler rows will be inserted here by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Fall of Wickets Section (Live) -->
            <div class="mt-8" id="liveFOW">
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Fall of Wickets (<span id="fowTeamName"></span>)</h3>
                <ul id="fallOfWicketsList" class="fall-of-wickets-list">
                    <!-- Fall of wickets will be inserted here by JavaScript -->
                </ul>
            </div>

            <!-- Match Result Display -->
            <div id="matchResultDisplay" class="match-result hidden">
                Match Result will appear here!
            </div>

            <!-- Man of the Match Display -->
            <div id="manOfTheMatchDisplay" class="man-of-the-match hidden">
                Man of the Match: <span id="manOfTheMatchPlayer"></span>
            </div>

            <!-- Final Scorecards Section (initially hidden) -->
            <div id="finalScorecardsSection" class="hidden mt-8 p-4 bg-gray-100 rounded-lg shadow-inner">
                <h2 class="text-2xl font-semibold text-gray-700 mb-6 text-center">Match Summary & Full Scorecards</h2>

                <!-- Team 1 Final Scorecards -->
                <div class="mb-8">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 text-center" id="finalTeam1Name"></h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Batsman Scorecard</h4>
                            <div class="overflow-x-auto">
                                <table id="finalTeam1BatsmanScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Batsman</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Balls</th>
                                            <th class="text-right">SR</th> <!-- Added Strike Rate header -->
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 1 Batsman rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Bowler Scorecard</h4>
                            <div class="overflow-x-auto">
                                <table id="finalTeam1BowlerScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Bowler</th>
                                            <th class="text-right">Overs</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Wickets</th>
                                            <th class="text-right">WD</th>
                                            <th class="text-right">NB</th>
                                            <th class="text-right">Econ</th> <!-- Added Economy header -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 1 Bowler rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <h4 class="text-lg font-semibold text-gray-700 mb-2">Fall of Wickets</h4>
                        <ul id="finalTeam1FOWList" class="fall-of-wickets-list">
                            <!-- Team 1 FOW will be inserted here -->
                        </ul>
                    </div>
                </div>

                <!-- Team 2 Final Scorecards -->
                <div>
                    <h3 class="text-xl font-bold text-gray-800 mb-4 text-center" id="finalTeam2Name"></h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Batsman Scorecard</h4>
                            <div class="overflow-x-auto">
                                <table id="finalTeam2BatsmanScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Batsman</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Balls</th>
                                            <th class="text-right">SR</th> <!-- Added Strike Rate header -->
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 2 Batsman rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Bowler Scorecard</th>
                            <div class="overflow-x-auto">
                                <table id="finalTeam2BowlerScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Bowler</th>
                                            <th class="text-right">Overs</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Wickets</th>
                                            <th class="text-right">WD</th>
                                            <th class="text-right">NB</th>
                                            <th class="text-right">Econ</th> <!-- Added Economy header -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 2 Bowler rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <h4 class="text-lg font-semibold text-gray-700 mb-2">Fall of Wickets</h4>
                        <ul id="finalTeam2FOWList" class="fall-of-wickets-list">
                            <!-- Team 2 FOW will be inserted here -->
                        </ul>
                    </div>
                </div>
            </div>

            <div class="flex justify-center mt-8 gap-4"> <!-- Changed from text-center to flex justify-center gap-4 -->
                <button id="endMatchBtn" class="hidden">End Match</button>
                <button id="newMatchBtn">New Match</button>
            </div>
        </div>

        <!-- Past Matches Section -->
        <div id="pastMatchesSection" class="past-matches-section">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">Past Match Summaries</h2>
            <ul id="pastMatchesList" class="past-matches-list">
                <!-- Past matches will be loaded here from localStorage -->
            </ul>
            <div class="flex justify-center mt-4"> <!-- Changed from text-center to flex justify-center -->
                <button id="clearPastMatchesBtn">Clear All Past Matches</button>
            </div>
        </div>

        <!-- Developer Info Section (NEW) -->
        <div id="developerInfoSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Developer Information</h2>
            <p>Developed by: SM0786</p>
            <p>Contact: testemail@gmail.com</p>
            <p>&copy; 2025 SM0786. All rights reserved.</p>
            <div class="flex justify-center"> <!-- Added flex justify-center to center the button -->
                <button id="backToMainBtn">Back to Main</button>
            </div>
        </div>


        <!-- Message Box for notifications -->
        <div id="messageBox" class="message-box"></div>

        <!-- Custom Confirmation Modal -->
        <div id="confirmationModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-white p-8 rounded-lg shadow-xl text-center">
                <p id="confirmationMessage" class="text-xl font-semibold text-gray-800 mb-6"></p>
                <button id="confirmYesBtn">Yes</button>
                <button id="confirmNoBtn">No</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Get references to HTML elements
        const teamRegistrationSection = document.getElementById('teamRegistrationSection');
        const scoreboardSection = document.getElementById('scoreboardSection');
        const teamRegistrationForm = document.getElementById('teamRegistrationForm');
        const messageBox = document.getElementById('messageBox');
        const matchReadySection = document.getElementById('matchReadySection'); // New
        const startMatchBtn = document.getElementById('startMatchBtn'); // New
        const registeredTeamsSummary = document.getElementById('registeredTeamsSummary'); // New

        // Toss Section elements (NEW)
        const tossSection = document.getElementById('tossSection');
        const tossWinnerSelect = document.getElementById('tossWinner');
        const tossDecisionSelect = document.getElementById('tossDecision');
        const proceedToMatchReadyBtn = document.getElementById('proceedToMatchReadyBtn');

        // Live Scoreboard elements
        const displayTeam1Name = document.getElementById('displayTeam1Name');
        const team1RunsDisplay = document.getElementById('team1Runs');
        const team1WicketsDisplay = document.getElementById('team1Wickets');
        const team1OversDisplay = document.getElementById('team1Overs');
        const team1ExtrasDisplay = document.getElementById('team1Extras');
        const team1Card = document.getElementById('team1Card');

        const displayTeam2Name = document.getElementById('displayTeam2Name');
        const team2RunsDisplay = document.getElementById('team2Runs');
        const team2WicketsDisplay = document.getElementById('team2Wickets');
        const team2OversDisplay = document.getElementById('team2Overs');
        const team2ExtrasDisplay = document.getElementById('team2Extras');
        const team2Card = document.getElementById('team2Card');

        const currentBattingTeamContainer = document.getElementById('currentBattingTeamContainer'); // NEW ID
        const currentBattingTeamDisplay = document.getElementById('currentBattingTeam');
        const oversRemainingContainer = document.getElementById('oversRemainingContainer'); // NEW ID
        const oversRemainingDisplay = document.getElementById('oversRemaining');
        const tossInfoDisplay = document.getElementById('tossInfoDisplay'); // NEW: Toss Info Display
        const tossWinnerInfo = document.getElementById('tossWinnerInfo'); // NEW: Toss Winner Info
        const tossDecisionInfo = document.getElementById('tossDecisionInfo'); // NEW: Toss Decision Info
        const targetScoreDisplayElement = document.getElementById('targetScoreDisplay');
        const targetScoreElement = document.getElementById('targetScore');
        const freeHitDisplay = document.getElementById('freeHitDisplay'); // New: Free Hit display

        // NEW: Chasing info elements
        const chasingInfoDisplay = document.getElementById('chasingInfoDisplay');
        const runsRequiredDisplay = document.getElementById('runsRequired');
        const ballsRemainingDisplay = document.getElementById('ballsRemaining');
        const wicketsRemainingDisplay = document.getElementById('wicketsRemaining');


        // Player selection dropdowns
        const playerSelection = document.getElementById('playerSelection');
        const strikerSelect = document.getElementById('strikerSelect');
        const nonStrikerSelect = document.getElementById('nonStrikerSelect');
        const bowlerSelect = document.getElementById('bowlerSelect');

        // Score control buttons
        const scoreControls = document.getElementById('scoreControls');
        const add1RunBtn = document.getElementById('add1RunBtn');
        const add2RunsBtn = document.getElementById('add2RunsBtn');
        const add4RunsBtn = document.getElementById('add4RunsBtn');
        const add6RunsBtn = document.getElementById('add6RunsBtn');
        // New Wicket Buttons
        const addCaughtBtn = document.getElementById('addCaughtBtn');
        const addBowledLbwBtn = document.getElementById('addBowledLbwBtn');
        const addRunOutBtn = document.getElementById('addRunOutBtn');
        const addStumpedBtn = document.getElementById('addStumpedBtn');
        const addHitWicketBtn = document.getElementById('addHitWicketBtn');
        const addOtherWicketBtn = document.getElementById('addOtherWicketBtn');

        const addBallBtn = document.getElementById('addBallBtn');
        const addWideBtn = document.getElementById('addWideBtn'); // Corrected line
        const addNoBallBtn = document.getElementById('addNoBallBtn');
        const addByeBtn = document.getElementById('addByeBtn');
        const addLegByeBtn = document.getElementById('addLegByeBtn');
        const switchStrikeBtn = document.getElementById('switchStrikeBtn');
        const undoBtn = document.getElementById('undoBtn');
        const switchTeamBtn = document.getElementById('switchTeamBtn');
        const newMatchBtn = document.getElementById('newMatchBtn');
        const endMatchBtn = document.getElementById('endMatchBtn'); // New: End Match button

        const matchResultDisplay = document.getElementById('matchResultDisplay');
        const manOfTheMatchDisplay = document.getElementById('manOfTheMatchDisplay');
        const manOfTheMatchPlayer = document.getElementById('manOfTheMatchPlayer');

        // Live Scorecard tables
        const liveBatsmanScorecardTable = document.getElementById('batsmanScorecard').getElementsByTagName('tbody')[0];
        const liveBowlerScorecardTable = document.getElementById('bowlerScorecard').getElementsByTagName('tbody')[0];
        const liveBatsmanScorecardTeamName = document.getElementById('batsmanScorecardTeamName');
        const liveBowlerScorecardTeamName = document.getElementById('bowlerScorecardTeamName');
        const liveFallOfWicketsList = document.getElementById('fallOfWicketsList');
        const liveFowTeamName = document.getElementById('fowTeamName');
        const liveScorecardsSection = document.getElementById('liveScorecards');
        const liveFOWSection = document.getElementById('liveFOW');
        const liveScorePanel = document.querySelector('.live-score-panel'); // NEW: Reference to the live score panel

        // Final Scorecards elements
        const finalScorecardsSection = document.getElementById('finalScorecardsSection');
        const finalTeam1NameDisplay = document.getElementById('finalTeam1Name');
        const finalTeam2NameDisplay = document.getElementById('finalTeam2Name');
        const finalTeam1BatsmanScorecardTable = document.getElementById('finalTeam1BatsmanScorecard').getElementsByTagName('tbody')[0];
        const finalTeam1BowlerScorecardTable = document.getElementById('finalTeam1BowlerScorecard').getElementsByTagName('tbody')[0];
        const finalTeam1FOWList = document.getElementById('finalTeam1FOWList');
        const finalTeam2BatsmanScorecardTable = document.getElementById('finalTeam2BatsmanScorecard').getElementsByTagName('tbody')[0];
        const finalTeam2BowlerScorecardTable = document.getElementById('finalTeam2BowlerScorecard').getElementsByTagName('tbody')[0];
        const finalTeam2FOWList = document.getElementById('finalTeam2FOWList');

        // Past Matches elements
        const pastMatchesSection = document.getElementById('pastMatchesSection');
        const pastMatchesList = document.getElementById('pastMatchesList');
        const clearPastMatchesBtn = document.getElementById('clearPastMatchesBtn');

        // New UI elements for live score page
        const currentOverInfoPanel = document.getElementById('currentOverInfoPanel'); // NEW ID
        const currentOverBallsDisplay = document.getElementById('currentOverBallsDisplay');
        const partnershipInfoPanel = document.getElementById('partnershipInfoPanel'); // NEW ID
        const partnershipRunsDisplay = document.getElementById('partnershipRunsDisplay');

        // Developer Info elements (NEW)
        const developerInfoSection = document.getElementById('developerInfoSection');
        let showDeveloperInfoBtn; // Declared here, initialized after its creation

        const backToMainBtn = document.getElementById('backToMainBtn'); // New button

        // Custom Confirmation Modal elements
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmationMessage = document.getElementById('confirmationMessage');
        const confirmYesBtn = document.getElementById('confirmYesBtn');
        const confirmNoBtn = document.getElementById('confirmNoBtn');

        // Array of all main content sections to easily hide/show them
        const allSections = [
            teamRegistrationSection,
            matchReadySection,
            tossSection, // Add toss section to the list
            scoreboardSection,
            pastMatchesSection,
            developerInfoSection
        ];

        // Function to hide all main content sections
        function hideAllSections() {
            allSections.forEach(section => section.classList.add('hidden'));
        }

        // Game state variables
        let team1 = {
            name: '',
            players: [], // Each player will be { name, runsScored, ballsFaced, isOut, wicketsTaken, runsConceded, ballsBowled, wides, noBalls, oversBowled }
            runs: 0,
            wickets: 0,
            overs: 0,
            balls: 0,
            totalWides: 0,
            totalNoBalls: 0,
            totalByes: 0,
            totalLegByes: 0,
            currentStrikerIndex: -1,
            currentNonStrikerIndex: -1,
            fallOfWickets: [] // [{ batsman: 'Name', score: 'X/Y', over: 'A.B', dismissalType: 'Caught' }]
        };
        let team2 = {
            name: '',
            players: [],
            runs: 0,
            wickets: 0,
            overs: 0,
            balls: 0,
            totalWides: 0,
            totalNoBalls: 0,
            totalByes: 0,
            totalLegByes: 0,
            currentStrikerIndex: -1,
            currentNonStrikerIndex: -1,
            fallOfWickets: []
        };
        let currentBattingTeam = null; // Reference to the currently batting team object
        let currentBowlingTeam = null; // Reference to the currently bowling team object
        let currentBowlerIndex = -1; // Index of the current bowler in the bowling team's players array

        let totalOversPerInnings = 0;
        let matchState = 'registration'; // 'registration', 'toss', 'teams_registered', 'innings1', 'innings2', 'completed'
        let firstInningsTotalRuns = 0;

        let lastAction = null; // Stores the last action for undo functionality

        let currentPartnershipRuns = 0; // New: Tracks runs scored by the current batting pair
        let isFreeHit = false; // New: Free hit state
        let lastCompletedBowlerIndex = -1; // New: Stores the index of the bowler who just completed an over

        let tossWinnerName = ''; // NEW: Stores the name of the team that won the toss
        let tossDecision = ''; // NEW: Stores the toss decision ('bat' or 'bowl')


        // Function to show a message box
        function showMessageBox(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = `message-box show ${type}`; // Add show and type class
            setTimeout(() => {
                messageBox.classList.remove('show'); // Hide after 3 seconds
            }, 3000);
        }

        // Function to show a custom confirmation modal
        function showConfirmationModal(message, onConfirm, onCancel) {
            confirmationMessage.textContent = message;
            confirmationModal.classList.remove('hidden');

            // Remove existing listeners to prevent multiple calls
            confirmYesBtn.removeEventListener('click', confirmYesBtn.currentListener);
            confirmNoBtn.removeEventListener('click', confirmNoBtn.currentListener);

            const handleConfirm = () => {
                confirmationModal.classList.add('hidden');
                onConfirm();
            };

            const handleCancel = () => {
                confirmationModal.classList.add('hidden');
                if (onCancel) onCancel();
            };

            // Store and add new listeners
            confirmYesBtn.currentListener = handleConfirm;
            confirmNoBtn.currentListener = handleCancel;
            confirmYesBtn.addEventListener('click', confirmYesBtn.currentListener);
            confirmNoBtn.addEventListener('click', confirmNoBtn.currentListener);
        }

        // Function to populate player dropdowns
        function populatePlayerDropdowns() {
            strikerSelect.innerHTML = '<option value="">Select Striker</option>';
            nonStrikerSelect.innerHTML = '<option value="">Select Non-Striker</option>'; // Corrected this line
            bowlerSelect.innerHTML = '<option value="">Select Bowler</option>';

            if (currentBattingTeam && currentBowlingTeam) {
                // Populate batsmen for the batting team
                currentBattingTeam.players.forEach((player, index) => {
                    // Only add players who are not out
                    if (!player.isOut) {
                        const optionStriker = document.createElement('option');
                        optionStriker.value = index;
                        optionStriker.textContent = player.name;
                        strikerSelect.appendChild(optionStriker);

                        const optionNonStriker = document.createElement('option');
                        optionNonStriker.value = index;
                        optionNonStriker.textContent = player.name;
                        nonStrikerSelect.appendChild(optionNonStriker);
                    }
                });

                // Populate bowlers for the bowling team
                currentBowlingTeam.players.forEach((player, index) => {
                    const optionBowler = document.createElement('option');
                    optionBowler.value = index;
                    optionBowler.textContent = player.name;
                    // Disable the last bowler if it's a new over (currentBattingTeam.balls === 0)
                    // and the bowler's index matches the lastCompletedBowlerIndex
                    if (index === lastCompletedBowlerIndex && currentBattingTeam.balls === 0) {
                        optionBowler.disabled = true;
                        optionBowler.textContent += ' (Last Over)'; // Add a visual cue
                    }
                    bowlerSelect.appendChild(optionBowler);
                });

                // Set selected values if batsmen/bowler are already chosen
                strikerSelect.value = currentBattingTeam.currentStrikerIndex !== -1 ? currentBattingTeam.currentStrikerIndex : '';
                nonStrikerSelect.value = currentBattingTeam.currentNonStrikerIndex !== -1 ? currentBattingTeam.currentNonStrikerIndex : '';
                bowlerSelect.value = currentBowlerIndex !== -1 ? currentBowlerIndex : '';
            }
        }

        // Event listeners for player selection changes
        strikerSelect.addEventListener('change', (event) => {
            const newStrikerIndex = parseInt(event.target.value);
            if (newStrikerIndex === currentBattingTeam.currentNonStrikerIndex) {
                showMessageBox('Striker and Non-Striker cannot be the same player.', 'error');
                strikerSelect.value = currentBattingTeam.currentStrikerIndex !== -1 ? currentBattingTeam.currentStrikerIndex : '';
                return;
            }
            currentBattingTeam.currentStrikerIndex = newStrikerIndex;
            showMessageBox(`${currentBattingTeam.players[newStrikerIndex].name} is now the Striker.`, 'success');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        });

        nonStrikerSelect.addEventListener('change', (event) => {
            const newNonStrikerIndex = parseInt(event.target.value);
            if (newNonStrikerIndex === currentBattingTeam.currentStrikerIndex) {
                showMessageBox('Striker and Non-Striker cannot be the same player.', 'error');
                nonStrikerSelect.value = currentBattingTeam.currentNonStrikerIndex !== -1 ? currentBattingTeam.currentNonStrikerIndex : '';
                return;
            }
            currentBattingTeam.currentNonStrikerIndex = newNonStrikerIndex;
            showMessageBox(`${currentBattingTeam.players[newNonStrikerIndex].name} is now the Non-Striker.`, 'success');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        });

        bowlerSelect.addEventListener('change', (event) => {
            const newBowlerIndex = parseInt(event.target.value);

            // Check if it's the start of a new over AND the selected bowler is the one who just bowled
            if (currentBattingTeam.balls === 0 && newBowlerIndex === lastCompletedBowlerIndex) {
                showMessageBox('This bowler cannot bowl the next over. Please select a different bowler.', 'error');
                bowlerSelect.value = ''; // Reset dropdown to empty
                currentBowlerIndex = -1; // Ensure no bowler is selected
                return; // Stop further execution
            }

            // If a valid bowler is selected (either not the previous bowler, or it's not the start of a new over)
            currentBowlerIndex = newBowlerIndex;
            showMessageBox(`${currentBowlingTeam.players[currentBowlerIndex].name} is now bowling.`, 'success');

            // Note: lastCompletedBowlerIndex is now only cleared when the first ball of the *new* over is bowled.
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal();
        });

        // Function to update the scoreboard display and scorecards
        function updateScoreboardDisplay() {
            // Update Team 1 display
            displayTeam1Name.textContent = team1.name;
            team1RunsDisplay.textContent = team1.runs;
            team1WicketsDisplay.textContent = team1.wickets;
            team1OversDisplay.textContent = `${team1.overs}.${team1.balls}`;
            team1ExtrasDisplay.textContent = team1.totalWides + team1.totalNoBalls + team1.totalByes + team1.totalLegByes;

            // Update Team 2 display
            displayTeam2Name.textContent = team2.name;
            team2RunsDisplay.textContent = team2.runs;
            team2WicketsDisplay.textContent = team2.wickets;
            team2OversDisplay.textContent = `${team2.overs}.${team2.balls}`;
            team2ExtrasDisplay.textContent = team2.totalWides + team2.totalNoBalls + team2.totalByes + team2.totalLegByes;

            // Highlight the current batting team
            team1Card.classList.remove('active');
            team2Card.classList.remove('active');
            if (currentBattingTeam === team1) {
                team1Card.classList.add('active');
                currentBattingTeamDisplay.textContent = team1.name;
            } else if (currentBattingTeam === team2) {
                team2Card.classList.add('active');
                currentBattingTeamDisplay.textContent = team2.name;
            } else {
                currentBattingTeamDisplay.textContent = 'N/A'; // No team batting yet
            }

            // Update overs remaining
            if (matchState === 'innings1' || matchState === 'innings2') {
                const ballsBowledInCurrentOver = currentBattingTeam.balls;
                const fullOversBowled = currentBattingTeam.overs;
                const totalBallsBowled = (fullOversBowled * 6) + ballsBowledInCurrentOver;
                const totalBallsInMatch = totalOversPerInnings * 6;
                const ballsRemainingOverall = totalBallsInMatch - totalBallsBowled;

                if (ballsRemainingOverall >= 0) {
                    const remainingOvers = Math.floor(ballsRemainingOverall / 6);
                    const remainingBalls = ballsRemainingOverall % 6;
                    oversRemainingDisplay.textContent = `${remainingOvers}.${remainingBalls}`;
                } else {
                    oversRemainingDisplay.textContent = '0.0'; // Should not happen if logic is correct
                }
            } else {
                oversRemainingDisplay.textContent = 'N/A';
            }

            // Show/hide target score and chasing info
            if (matchState === 'innings2') {
                targetScoreDisplayElement.classList.remove('hidden');
                targetScoreElement.textContent = firstInningsTotalRuns + 1;

                const runsNeeded = (firstInningsTotalRuns + 1) - currentBattingTeam.runs;
                const ballsLeft = (totalOversPerInnings * 6) - (currentBattingTeam.overs * 6 + currentBattingTeam.balls);
                const wicketsLeft = (currentBattingTeam.players.length - 1) - currentBattingTeam.wickets;

                runsRequiredDisplay.textContent = Math.max(0, runsNeeded); // Ensure non-negative
                ballsRemainingDisplay.textContent = Math.max(0, ballsLeft); // Ensure non-negative
                wicketsRemainingDisplay.textContent = Math.max(0, wicketsLeft); // Ensure non-negative

                chasingInfoDisplay.classList.remove('hidden');

            } else {
                targetScoreDisplayElement.classList.add('hidden');
                chasingInfoDisplay.classList.add('hidden'); // Hide chasing info if not innings 2
            }

            // Update new UI elements
            currentOverBallsDisplay.textContent = currentBattingTeam ? currentBattingTeam.balls : 0;
            partnershipRunsDisplay.textContent = currentPartnershipRuns;

            // Update Free Hit display
            if (isFreeHit) {
                freeHitDisplay.classList.remove('hidden');
            } else {
                freeHitDisplay.classList.add('hidden');
            }

            // Manage visibility of live score info boxes based on match state
            if (matchState === 'innings1' || matchState === 'innings2') {
                currentBattingTeamContainer.classList.remove('hidden');
                oversRemainingContainer.classList.remove('hidden');
                tossInfoDisplay.classList.remove('hidden'); // Show toss info
                tossWinnerInfo.textContent = tossWinnerName;
                tossDecisionInfo.textContent = tossDecision;
                currentOverInfoPanel.classList.remove('hidden');
                partnershipInfoPanel.classList.remove('hidden');
                liveScorecardsSection.classList.remove('hidden');
                liveFOWSection.classList.remove('hidden');
                playerSelection.classList.remove('hidden');
                scoreControls.classList.remove('hidden');
                liveScorePanel.classList.remove('hidden'); // Ensure live score panel is visible
            } else if (matchState === 'completed') {
                currentBattingTeamContainer.classList.add('hidden');
                oversRemainingContainer.classList.add('hidden');
                tossInfoDisplay.classList.add('hidden'); // Hide toss info
                currentOverInfoPanel.classList.add('hidden');
                partnershipInfoPanel.classList.add('hidden');
                liveScorecardsSection.classList.add('hidden'); // Ensure live scorecards are hidden
                liveFOWSection.classList.add('hidden'); // Ensure live FOW is hidden
                playerSelection.classList.add('hidden'); // Ensure player selection is hidden
                scoreControls.classList.add('hidden'); // Ensure score controls are hidden
                liveScorePanel.classList.add('hidden'); // NEW: Hide the live score panel
            } else { // registration, teams_registered, toss
                currentBattingTeamContainer.classList.add('hidden');
                oversRemainingContainer.classList.add('hidden');
                tossInfoDisplay.classList.add('hidden'); // Hide toss info
                currentOverInfoPanel.classList.add('hidden');
                partnershipInfoPanel.classList.add('hidden');
                liveScorecardsSection.classList.add('hidden');
                liveFOWSection.classList.add('hidden');
                playerSelection.classList.add('hidden');
                scoreControls.classList.add('hidden');
                liveScorePanel.classList.add('hidden'); // Hide the live score panel
            }

            // Only render live scorecards if match is not completed
            if (matchState === 'innings1' || matchState === 'innings2') { // Only render if match is active
                renderBatsmanScorecard(currentBattingTeam, liveBatsmanScorecardTable, liveBatsmanScorecardTeamName);
                renderBowlerScorecard(currentBowlingTeam, liveBowlerScorecardTable, liveBowlerScorecardTeamName);
                renderFallOfWickets(currentBattingTeam, liveFallOfWicketsList, liveFowTeamName);
                populatePlayerDropdowns(); // Re-populate dropdowns to update selected players
            }
        }

        // Function to add runs
        function addRuns(runs) {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBattingTeam.currentStrikerIndex === -1 || currentBowlerIndex === -1) {
                showMessageBox('Please select striker and bowler.', 'error');
                return;
            }

            const striker = currentBattingTeam.players[currentBattingTeam.currentStrikerIndex];
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            striker.runsScored += runs;
            striker.ballsFaced++;
            currentBattingTeam.runs += runs;
            bowler.runsConceded += runs;
            currentBattingTeam.balls++; // A run implies a ball bowled
            bowler.ballsBowled++;

            // Store previous partnership runs for undo
            lastAction = {
                type: 'run',
                runs: runs,
                strikerIndex: currentBattingTeam.currentStrikerIndex,
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                wasStrikeSwitched: false, // Will be updated if strike is switched
                prevPartnershipRuns: currentPartnershipRuns, // Store partnership before this action
                prevIsFreeHit: isFreeHit
            };
            currentPartnershipRuns += runs; // Update partnership

            // If runs are odd, switch strike
            if (runs % 2 !== 0) {
                switchStrike(true); // true means it's an automatic switch
                lastAction.wasStrikeSwitched = true;
            }

            isFreeHit = false; // Free hit ends after a legal delivery
            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to add a wicket
        function addWicket(dismissalType) {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBattingTeam.currentStrikerIndex === -1 || currentBowlerIndex === -1) {
                showMessageBox('Please select striker and bowler.', 'error');
                return;
            }

            const striker = currentBattingTeam.players[currentBattingTeam.currentStrikerIndex];
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            // Determine the maximum wickets allowed for this team (all players except one)
            const maxWickets = currentBattingTeam.players.length - 1;

            if (currentBattingTeam.wickets < maxWickets) {
                if (isFreeHit && dismissalType !== 'Run Out') { // Run Out is the only dismissal on a free hit
                    showMessageBox(`Wicket on Free Hit! ${striker.name} is not out (${dismissalType}), but ball counted.`, 'info');
                    striker.ballsFaced++; // Still counts as a ball faced
                    bowler.ballsBowled++; // Still counts as a ball bowled
                    currentBattingTeam.balls++; // Still counts as a ball in the over
                    // No wicket is recorded, no change to runs
                    lastAction = {
                        type: 'freeHitWicketAttempt',
                        strikerIndex: currentBattingTeam.currentStrikerIndex,
                        bowlerIndex: currentBowlerIndex,
                        team: currentBattingTeam === team1 ? 'team1' : 'team2',
                        prevPartnershipRuns: currentPartnershipRuns,
                        prevIsFreeHit: isFreeHit,
                        dismissalType: dismissalType // Store for undo message
                    };
                    isFreeHit = false; // Free hit ends
                } else {
                    striker.isOut = true;
                    currentBattingTeam.wickets++;
                    if (dismissalType !== 'Run Out' && dismissalType !== 'Hit Wicket') { // Bowler gets credit for most wickets
                        bowler.wicketsTaken++;
                    }
                    striker.ballsFaced++; // A wicket implies a ball bowled
                    bowler.ballsBowled++;
                    currentBattingTeam.balls++;

                    // Record fall of wicket
                    currentBattingTeam.fallOfWickets.push({
                        batsman: striker.name,
                        score: `${currentBattingTeam.runs}/${currentBattingTeam.wickets}`,
                        over: `${currentBattingTeam.overs}.${currentBattingTeam.balls}`,
                        dismissalType: dismissalType
                    });

                    // Store previous partnership runs for undo
                    lastAction = {
                        type: 'wicket',
                        batsmanOutIndex: currentBattingTeam.currentStrikerIndex,
                        bowlerIndex: currentBowlerIndex,
                        team: currentBattingTeam === team1 ? 'team1' : 'team2',
                        previousStrikerIndex: currentBattingTeam.currentStrikerIndex,
                        previousNonStrikerIndex: currentBattingTeam.currentNonStrikerIndex,
                        prevPartnershipRuns: currentPartnershipRuns, // Store partnership before this action
                        prevIsFreeHit: isFreeHit,
                        dismissalType: dismissalType // Store dismissal type for undo
                    };
                    currentPartnershipRuns = 0; // Reset partnership on wicket

                    // Select next batsman
                    let nextBatsmanIndex = -1;
                    for (let i = 0; i < currentBattingTeam.players.length; i++) {
                        if (!currentBattingTeam.players[i].isOut && i !== currentBattingTeam.currentNonStrikerIndex) {
                            nextBatsmanIndex = i;
                            break;
                        }
                    }

                    if (nextBatsmanIndex !== -1) {
                        currentBattingTeam.currentStrikerIndex = nextBatsmanIndex;
                        showMessageBox(`${striker.name} is out by ${dismissalType}! ${currentBattingTeam.players[nextBatsmanIndex].name} is new striker.`, 'success');
                    } else {
                        // All out scenario (no more available batsmen)
                        currentBattingTeam.currentStrikerIndex = -1;
                        currentBattingTeam.currentNonStrikerIndex = -1;
                        showMessageBox(`${striker.name} is out by ${dismissalType}! ${currentBattingTeam.name} All Out!`, 'success');
                    }
                    isFreeHit = false; // Free hit ends after a legal delivery (even if it's a wicket)
                }
                checkInningsCompletion();
                updateScoreboardDisplay();
                saveCurrentMatchStateToLocal(); // Save changes to local storage
            } else {
                showMessageBox(`${currentBattingTeam.name} is already all out!`, 'error');
            }
        }

        // Function to add a dot ball
        function addBall() {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBattingTeam.currentStrikerIndex === -1 || currentBowlerIndex === -1) {
                showMessageBox('Please select striker and bowler.', 'error');
                return;
            }

            const striker = currentBattingTeam.players[currentBattingTeam.currentStrikerIndex];
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            striker.ballsFaced++;
            bowler.ballsBowled++;
            currentBattingTeam.balls++;

            // Store previous partnership runs for undo (no change to partnership for dot ball)
            lastAction = {
                type: 'ball',
                strikerIndex: currentBattingTeam.currentStrikerIndex,
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            isFreeHit = false; // Free hit ends after a legal delivery

            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Functions for Extras
        function addWide() {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // Wide does not count as a legal delivery, so it doesn't clear lastCompletedBowlerIndex
            // if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
            //     lastCompletedBowlerIndex = -1; // This should NOT happen for extras
            // }

            currentBattingTeam.runs += 1; // 1 run for wide
            currentBattingTeam.totalWides += 1;
            bowler.runsConceded += 1;
            bowler.wides += 1;

            // Store previous partnership runs for undo (partnership does not increase for extras not off bat)
            lastAction = {
                type: 'wide',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            // Wide does not end a free hit, as it's not a legal delivery
            checkInningsCompletion(); // Wide doesn't count as a ball, but check innings completion
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        function addNoBall() {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // No ball does not count as a legal delivery, so it doesn't clear lastCompletedBowlerIndex
            // if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
            //     lastCompletedBowlerIndex = -1; // This should NOT happen for extras
            // }

            currentBattingTeam.runs += 1; // 1 run for no ball
            currentBattingTeam.totalNoBalls += 1;
            bowler.runsConceded += 1;
            bowler.noBalls += 1;

            // Store previous partnership runs for undo (partnership does not increase for extras not off bat)
            lastAction = {
                type: 'noBall',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            isFreeHit = true; // Set free hit for the next ball
            showMessageBox('No Ball! Free Hit on next delivery!', 'info');

            checkInningsCompletion(); // No ball doesn't count as a ball, but check innings completion
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        function addBye() {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            currentBattingTeam.runs += 1; // 1 run for bye
            currentBattingTeam.totalByes += 1;
            currentBattingTeam.balls++; // Bye counts as a ball
            bowler.ballsBowled++; // Bowler bowls a ball

            // Store previous partnership runs for undo (partnership does not increase for extras not off bat)
            lastAction = {
                type: 'bye',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            isFreeHit = false; // Free hit ends after a legal delivery (even if it's a bye)

            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        function addLegBye() {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            currentBattingTeam.runs += 1; // 1 run for leg bye
            currentBattingTeam.totalLegByes += 1;
            currentBattingTeam.balls++; // Leg bye counts as a ball
            bowler.ballsBowled++; // Bowler bowls a ball

            // Store previous partnership runs for undo (partnership does not increase for extras not off bat)
            lastAction = {
                type: 'legBye',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            isFreeHit = false; // Free hit ends after a legal delivery (even if it's a leg bye)

            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to switch strike between the two current batsmen
        function switchStrike(isAutomatic = false) {
            if (currentBattingTeam.currentStrikerIndex !== -1 && currentBattingTeam.currentNonStrikerIndex !== -1) {
                const temp = currentBattingTeam.currentStrikerIndex;
                currentBattingTeam.currentStrikerIndex = currentBattingTeam.currentNonStrikerIndex;
                currentBattingTeam.currentNonStrikerIndex = temp;
                populatePlayerDropdowns(); // Update dropdowns to reflect strike change
                if (!isAutomatic) {
                    showMessageBox('Strike switched manually.', 'info');
                    saveCurrentMatchStateToLocal(); // Save changes to local storage
                }
            } else if (!isAutomatic) {
                showMessageBox('Cannot switch strike: ensure both batsmen are selected.', 'error');
            }
        }

        // Helper function to check for over completion and innings completion
        function checkInningsCompletion() {
            // Update full overs for the team
            if (currentBattingTeam.balls >= 6) {
                currentBattingTeam.overs += Math.floor(currentBattingTeam.balls / 6);
                currentBattingTeam.balls = currentBattingTeam.balls % 6;
                // After an over, automatically switch strike
                switchStrike(true); // Automatic switch
                lastCompletedBowlerIndex = currentBowlerIndex; // Store the bowler who just completed the over
                currentBowlerIndex = -1; // Reset current bowler
                bowlerSelect.value = ''; // Clear dropdown
                showMessageBox('Over completed! Select a new bowler.', 'info');
            }

            // Update full overs for the current bowler
            if (currentBowlerIndex !== -1) {
                const bowler = currentBowlingTeam.players[currentBowlerIndex];
                if (bowler.ballsBowled >= 6) {
                    bowler.oversBowled += Math.floor(bowler.ballsBowled / 6);
                    bowler.ballsBowled = bowler.ballsBowled % 6;
                }
            }

            // Determine the "all out" condition dynamically
            const isAllOut = currentBattingTeam.wickets === (currentBattingTeam.players.length - 1);
            const allOversBowled = currentBattingTeam.overs >= totalOversPerInnings;

            if (matchState === 'innings1') {
                if (isAllOut || allOversBowled) {
                    // Corrected: Set firstInningsTotalRuns to the runs of the team that just batted (currentBattingTeam)
                    firstInningsTotalRuns = currentBattingTeam.runs;
                    showMessageBox(`${currentBattingTeam.name} Innings Completed! Target for ${currentBowlingTeam.name} is ${firstInningsTotalRuns + 1}.`, 'success');
                    matchState = 'innings2';
                    switchBattingTeam(); // Automatically switch to the other team for chasing
                    updateScoreboardDisplay(); // Update display immediately after switch
                    saveCurrentMatchStateToLocal(); // Save changes to local storage
                }
            } else if (matchState === 'innings2') {
                // Check for win condition immediately when target is surpassed
                if (currentBattingTeam.runs > firstInningsTotalRuns) {
                    declareWinner();
                    return; // Exit to prevent further score updates
                }

                if (isAllOut || allOversBowled) {
                    declareWinner();
                }
            }
        }

        // Function to switch the batting team
        function switchBattingTeam() {
            if (matchState === 'completed') {
                showMessageBox('Match is completed. Start a new match.', 'error');
                return;
            }

            // Save current batsmen's state before switching
            if (currentBattingTeam) {
                currentBattingTeam.currentStrikerIndex = strikerSelect.value !== '' ? parseInt(strikerSelect.value) : -1;
                currentBattingTeam.currentNonStrikerIndex = nonStrikerSelect.value !== '' ? parseInt(nonStrikerSelect.value) : -1;
            }

            // Determine the next batting and bowling teams
            const nextBattingTeam = (currentBattingTeam === team1) ? team2 : team1;
            const nextBowlingTeam = (currentBattingTeam === team1) ? team1 : team2;

            currentBattingTeam = nextBattingTeam;
            currentBowlingTeam = nextBowlingTeam;

            // Reset current bowler for the new bowling team
            currentBowlerIndex = -1;
            lastCompletedBowlerIndex = -1; // Reset for new innings

            // Clear current batsmen for the new batting team if they haven't batted yet
            if (currentBattingTeam.currentStrikerIndex === -1 || currentBattingTeam.players[currentBattingTeam.currentStrikerIndex].isOut) {
                let availableBatsmen = currentBattingTeam.players.filter(p => !p.isOut);
                if (availableBatsmen.length >= 2) {
                    currentBattingTeam.currentStrikerIndex = currentBattingTeam.players.indexOf(availableBatsmen[0]);
                    currentBattingTeam.currentNonStrikerIndex = currentBattingTeam.players.indexOf(availableBatsmen[1]);
                } else if (availableBatsmen.length === 1) {
                    currentBattingTeam.currentStrikerIndex = availableBatsmen.length > 0 ? currentBattingTeam.players.indexOf(availableBatsmen[0]) : -1;
                    currentBattingTeam.currentNonStrikerIndex = -1; // Only one batsman left
                } else {
                    currentBattingTeam.currentStrikerIndex = -1;
                    currentBattingTeam.currentNonStrikerIndex = -1;
                }
            }

            currentPartnershipRuns = 0; // Reset partnership when switching batting teams
            isFreeHit = false; // Reset free hit on innings switch

            showMessageBox(`Switched to ${currentBattingTeam.name} batting!`, 'success');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to declare the winner and Man of the Match
        async function declareWinner() {
            matchState = 'completed';
            let resultMessage = '';

            // Determine which team batted first and which batted second
            // This logic needs to be based on `firstInningsTotalRuns` and the current `team1` and `team2` scores.
            // If `firstInningsTotalRuns` was set from `team1.runs`, then team1 batted first.
            // If `firstInningsTotalRuns` was set from `team2.runs`, then team2 batted first.
            const firstBattingTeam = (firstInningsTotalRuns === team1.runs) ? team1 : team2;
            const secondBattingTeam = (firstInningsTotalRuns === team1.runs) ? team2 : team1;


            // Determine if the second batting team chased the target successfully
            const targetChased = secondBattingTeam.runs > firstInningsTotalRuns;

            if (targetChased) {
                resultMessage = `${secondBattingTeam.name} wins by ${secondBattingTeam.players.length - 1 - secondBattingTeam.wickets} wickets!`;
            } else if (firstInningsTotalRuns > secondBattingTeam.runs) {
                // First batting team won (either by runs if second team all out/overs, or if target wasn't chased)
                resultMessage = `${firstBattingTeam.name} wins by ${firstInningsTotalRuns - secondBattingTeam.runs} runs!`;
            } else {
                // Scores are tied
                resultMessage = `Match Drawn!`;
            }

            // Determine Man of the Match
            const motmPlayer = determineManOfTheMatch();
            const motmName = motmPlayer ? motmPlayer.name : 'N/A';

            // Save match details to localStorage immediately
            saveMatchDetailsLocal(resultMessage, motmName);
            saveCurrentMatchStateToLocal(); // Save final state to local storage

            // The visibility of live score elements is now handled by updateScoreboardDisplay()
            // No need to explicitly hide them here.

            // Immediately show the match result (winner and difference)
            matchResultDisplay.textContent = resultMessage;
            matchResultDisplay.classList.remove('hidden');

            // Keep other summary elements hidden until "End Match" button is clicked
            manOfTheMatchDisplay.classList.add('hidden');
            finalScorecardsSection.classList.add('hidden');

            // Show End Match button and hide New Match button
            endMatchBtn.classList.remove('hidden');
            newMatchBtn.classList.add('hidden'); // Hide New Match button
            showMessageBox(`Match concluded! Click 'End Match' for full summary.`, 'success');
            console.log('declareWinner(): Match concluded. End Match button unhidden. Summary not yet displayed.');

            // Disable score controls
            Array.from(scoreControls.children).forEach(button => button.disabled = true);
            strikerSelect.disabled = true;
            nonStrikerSelect.disabled = true;
            bowlerSelect.disabled = true;

            // Update scoreboard display to reflect final state (this will hide the info boxes)
            updateScoreboardDisplay();
        }

        // Function to determine Man of the Match based on a simple heuristic
        function determineManOfTheMatch() {
            let allPlayers = [...team1.players, ...team2.players];
            let manOfTheMatch = null;
            let highestScore = -Infinity; // Initialize with negative infinity to ensure any valid score is higher

            allPlayers.forEach(player => {
                // Heuristic: Runs are highly valued, wickets are highly valued, low runs conceded are good.
                // Adjust weights as desired for different player types.
                let performanceScore = (player.runsScored * 2) + (player.wicketsTaken * 15) - (player.runsConceded * 0.5);

                // Add a small bonus for participation (e.g., if they faced balls or bowled)
                if (player.ballsFaced > 0 || player.ballsBowled > 0) {
                    performanceScore += 1;
                }
                
                // Prioritize players who actually contributed (e.g., non-zero runs or wickets)
                if (player.runsScored === 0 && player.wicketsTaken === 0 && player.wides === 0 && player.noBalls === 0 && player.ballsFaced === 0 && player.ballsBowled === 0) {
                    performanceScore = -Infinity; // Penalize players with absolutely no contribution
                }


                if (performanceScore > highestScore) {
                    highestScore = performanceScore;
                    manOfTheMatch = player;
                }
            });

            return manOfTheMatch;
        }


        // Function to undo the last action
        function undoLastAction() {
            if (!lastAction) {
                showMessageBox('No action to undo.', 'error');
                return;
            }

            const targetTeam = lastAction.team === 'team1' ? team1 : team2;
            // Determine the bowling team based on the current batting team (for extras/bowler stats)
            // This needs to be the team that was bowling when the action happened, not necessarily the currentBowlingTeam
            const bowlingTeamForUndo = (targetTeam === team1) ? team2 : team1;
            const currentBowler = bowlingTeamForUndo.players[lastAction.bowlerIndex];

            // Revert partnership runs and free hit state first
            currentPartnershipRuns = lastAction.prevPartnershipRuns;
            isFreeHit = lastAction.prevIsFreeHit;

            switch (lastAction.type) {
                case 'run':
                    const strikerForRun = targetTeam.players[lastAction.strikerIndex];
                    strikerForRun.runsScored -= lastAction.runs;
                    strikerForRun.ballsFaced--;
                    targetTeam.runs -= lastAction.runs;
                    currentBowler.runsConceded -= lastAction.runs;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    break;
                case 'wicket':
                    const batsmanOut = targetTeam.players[lastAction.batsmanOutIndex];
                    batsmanOut.isOut = false;
                    targetTeam.wickets--;
                    if (lastAction.dismissalType !== 'Run Out' && lastAction.dismissalType !== 'Hit Wicket') {
                        currentBowler.wicketsTaken--;
                    }
                    batsmanOut.ballsFaced--;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    targetTeam.currentStrikerIndex = lastAction.previousStrikerIndex;
                    targetTeam.currentNonStrikerIndex = lastAction.previousNonStrikerIndex;
                    // Remove last fall of wicket entry
                    if (targetTeam.fallOfWickets.length > 0) {
                        targetTeam.fallOfWickets.pop();
                    }
                    break;
                case 'freeHitWicketAttempt':
                    // No changes to runs/wickets, just ball counts
                    const strikerForFreeHit = targetTeam.players[lastAction.strikerIndex];
                    strikerForFreeHit.ballsFaced--;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    break;
                case 'ball':
                    // Corrected: Changed 'targetHteam' to 'targetTeam'
                    const strikerForBall = targetTeam.players[lastAction.strikerIndex];
                    strikerForBall.ballsFaced--;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    break;
                case 'wide':
                    targetTeam.runs -= 1;
                    targetTeam.totalWides -= 1;
                    currentBowler.runsConceded -= 1;
                    currentBowler.wides -= 1;
                    break;
                case 'noBall':
                    targetTeam.runs -= 1;
                    targetTeam.totalNoBalls -= 1;
                    currentBowler.runsConceded -= 1;
                    currentBowler.noBalls -= 1;
                    break;
                case 'bye':
                    targetTeam.runs -= 1;
                    targetTeam.totalByes -= 1;
                    targetTeam.balls--;
                    currentBowler.ballsBowled--;
                    break;
                case 'legBye':
                    targetTeam.runs -= 1;
                    targetTeam.totalLegByes -= 1;
                    targetTeam.balls--;
                    currentBowler.ballsBowled--;
                    break;
            }

            // If the last action involved an automatic strike switch, reverse it
            if (lastAction.wasStrikeSwitched) {
                switchStrike(true);
            }

            // Adjust overs if balls go negative or cross over boundary
            if (targetTeam.balls < 0) {
                targetTeam.overs--;
                targetTeam.balls += 6;
            }
            if (currentBowler.ballsBowled < 0) {
                currentBowler.oversBowled--;
                currentBowler.ballsBowled += 6;
            }

            // If undoing an action that was the first ball of an over, and a bowler was previously restricted,
            // reinstate that restriction. This is crucial for the bowler re-selection fix.
            // This logic is complex and might need more robust state management for `lastCompletedBowlerIndex`
            // if multiple undo operations are expected to cross over boundaries. For a single undo,
            // we can try to infer.
            // For now, let's assume `lastCompletedBowlerIndex` is only set on over completion and cleared on first ball.
            // If we undo the first ball, the restriction should conceptually return.
            // This is a tricky edge case for `undo`. For simplicity, we'll keep `lastCompletedBowlerIndex` as is,
            // and the `populatePlayerDropdowns` will handle disabling based on `currentBattingTeam.balls === 0`.
            // The main fix for re-selection is in the `bowlerSelect.addEventListener`.


            lastAction = null; // Clear last action after undo
            showMessageBox('Last action undone.', 'info');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to save current match state to local storage
        function saveCurrentMatchStateToLocal() {
            try {
                const currentMatchState = {
                    team1: team1,
                    team2: team2,
                    totalOversPerInnings: totalOversPerInnings,
                    matchState: matchState,
                    firstInningsTotalRuns: firstInningsTotalRuns,
                    currentBattingTeamName: currentBattingTeam ? currentBattingTeam.name : null,
                    currentBowlingTeamName: currentBowlingTeam ? currentBowlingTeam.name : null,
                    currentBowlerIndex: currentBowlerIndex,
                    currentStrikerIndex: currentBattingTeam ? currentBattingTeam.currentStrikerIndex : -1,
                    currentNonStrikerIndex: currentBattingTeam ? currentBattingTeam.currentNonStrikerIndex : -1,
                    currentPartnershipRuns: currentPartnershipRuns,
                    isFreeHit: isFreeHit, // Save free hit state
                    lastCompletedBowlerIndex: lastCompletedBowlerIndex, // Save last completed bowler
                    matchDate: document.getElementById('matchDate').value,
                    matchTime: document.getElementById('matchTime').value,
                    tossWinnerName: tossWinnerName, // NEW: Save toss winner
                    tossDecision: tossDecision // NEW: Save toss decision
                };
                localStorage.setItem('currentCricketMatch', JSON.stringify(currentMatchState));
                console.log("Current match state saved to local storage.");
            } catch (e) {
                console.error("Error saving current match state to local storage: ", e);
                showMessageBox('Failed to save current match state locally.', 'error');
            }
        }

        // Function to load current match state from local storage
        function loadCurrentMatchStateFromLocal() {
            try {
                const storedState = localStorage.getItem('currentCricketMatch');
                if (storedState) {
                    const loadedState = JSON.parse(storedState);
                    team1 = loadedState.team1;
                    team2 = loadedState.team2;
                    totalOversPerInnings = loadedState.totalOversPerInnings;
                    matchState = loadedState.matchState;
                    firstInningsTotalRuns = loadedState.firstInningsTotalRuns;
                    currentPartnershipRuns = loadedState.currentPartnershipRuns;
                    isFreeHit = loadedState.isFreeHit || false; // Load free hit state, default to false
                    lastCompletedBowlerIndex = loadedState.lastCompletedBowlerIndex || -1; // Load last completed bowler
                    tossWinnerName = loadedState.tossWinnerName || ''; // NEW: Load toss winner
                    tossDecision = loadedState.tossDecision || ''; // NEW: Load toss decision

                    // Re-establish object references for currentBattingTeam and currentBowlingTeam
                    if (loadedState.currentBattingTeamName === team1.name) {
                        currentBattingTeam = team1;
                        currentBowlingTeam = team2;
                    } else if (loadedState.currentBattingTeamName === team2.name) {
                        currentBattingTeam = team2;
                        currentBowlingTeam = team1;
                    } else {
                        currentBattingTeam = null;
                        currentBowlingTeam = null;
                    }

                    currentBowlerIndex = loadedState.currentBowlerIndex;
                    if (currentBattingTeam) {
                        currentBattingTeam.currentStrikerIndex = loadedState.currentStrikerIndex;
                        currentBattingTeam.currentNonStrikerIndex = loadedState.currentNonStrikerIndex;
                    }
                    
                    // Restore date and time inputs
                    document.getElementById('matchDate').value = loadedState.matchDate || '';
                    document.getElementById('matchTime').value = loadedState.matchTime || '';
                    document.getElementById('totalOvers').value = loadedState.totalOversPerInnings || '';
                    document.getElementById('team1Name').value = loadedState.team1.name || '';
                    document.getElementById('team2Name').value = loadedState.team2.name || '';
                    document.getElementById('team1Players').value = loadedState.team1.players.map(p => p.name).join('\n') || '';
                    document.getElementById('team2Players').value = loadedState.team2.players.map(p => p.name).join('\n') || '';


                    // Show appropriate section based on loaded match state
                    if (matchState === 'registration') {
                        hideAllSections();
                        teamRegistrationSection.classList.remove('hidden');
                        pastMatchesSection.classList.remove('hidden'); // Always show past matches
                        showDeveloperInfoBtn.classList.remove('hidden'); // Always show dev info button
                        newMatchBtn.classList.remove('hidden'); // New match button visible
                        clearPastMatchesBtn.classList.remove('hidden'); // Clear past matches button visible
                        endMatchBtn.classList.add('hidden'); // Hide end match button
                    } else if (matchState === 'toss') { // NEW: Handle toss state
                        hideAllSections();
                        tossSection.classList.remove('hidden');
                        populateTossDropdowns(); // Populate toss dropdowns with team names
                        showDeveloperInfoBtn.classList.remove('hidden');
                        newMatchBtn.classList.remove('hidden');
                        clearPastMatchesBtn.classList.remove('hidden');
                        endMatchBtn.classList.add('hidden');
                    } else if (matchState === 'teams_registered') {
                        hideAllSections();
                        matchReadySection.classList.remove('hidden');
                        registeredTeamsSummary.textContent = `${team1.name} vs ${team2.name} (${totalOversPerInnings} Overs per innings) on ${loadedState.matchDate} at ${loadedState.matchTime}. ${tossWinnerName} won the toss and chose to ${tossDecision} first.`;
                        showDeveloperInfoBtn.classList.remove('hidden');
                        newMatchBtn.classList.remove('hidden');
                        clearPastMatchesBtn.classList.remove('hidden');
                        endMatchBtn.classList.add('hidden');
                    } else if (matchState === 'innings1' || matchState === 'innings2') {
                        hideAllSections();
                        scoreboardSection.classList.remove('hidden');
                        showDeveloperInfoBtn.classList.remove('hidden'); // Always show dev info button
                        endMatchBtn.classList.add('hidden'); // Hide end match button if not completed
                        newMatchBtn.classList.add('hidden'); // Hide new match button during innings
                        console.log('loadCurrentMatchStateFromLocal(): End Match button hidden (innings in progress).');
                    } else if (matchState === 'completed') {
                        hideAllSections();
                        scoreboardSection.classList.remove('hidden');
                        // Show result immediately, but hide other summary elements
                        matchResultDisplay.classList.remove('hidden');
                        matchResultDisplay.textContent = loadedState.result; // Display the saved result
                        manOfTheMatchDisplay.classList.add('hidden');
                        finalScorecardsSection.classList.add('hidden');
                        endMatchBtn.classList.remove('hidden'); // Show end match button if completed
                        newMatchBtn.classList.add('hidden'); // Hide new match button until 'End Match' is clicked
                        console.log('loadCurrentMatchStateFromLocal(): End Match button unhidden (match completed), summary hidden.');
                        // Disable controls for completed match
                        Array.from(scoreControls.children).forEach(button => button.disabled = true);
                        strikerSelect.disabled = true;
                        nonStrikerSelect.disabled = true;
                        bowlerSelect.disabled = true;
                    }

                    updateScoreboardDisplay(); // This will now handle visibility of info boxes
                    // showMessageBox('Match state loaded from local storage.', 'info'); // Removed this message
                } else {
                    console.log("No previous match state found in local storage. Starting new registration.");
                    newMatch(); // Start a fresh match if no state found
                }
            } catch (e) {
                console.error("Error loading current match state from local storage: ", e);
                showMessageBox('Failed to load previous match state. Starting a new match.', 'error');
                    // Ensure the UI is in a consistent state even after error
                    hideAllSections();
                    teamRegistrationSection.classList.remove('hidden');
                    pastMatchesSection.classList.remove('hidden');
                    showDeveloperInfoBtn.classList.remove('hidden');
                    newMatchBtn.classList.remove('hidden'); // Make new match button visible on error/reset
                    clearPastMatchesBtn.classList.remove('hidden');
            }
        }


        // Function to reset the match
        function newMatch() {
            // Clear current match state from local storage
            localStorage.removeItem('currentCricketMatch');

            // Reset game state
            team1 = { name: '', players: [], runs: 0, wickets: 0, overs: 0, balls: 0, totalWides: 0, totalNoBalls: 0, totalByes: 0, totalLegByes: 0, currentStrikerIndex: -1, currentNonStrikerIndex: -1, fallOfWickets: [] };
            team2 = { name: '', players: [], runs: 0, wickets: 0, overs: 0, balls: 0, totalWides: 0, totalNoBalls: 0, totalByes: 0, totalLegByes: 0, currentStrikerIndex: -1, currentNonStrikerIndex: -1, fallOfWickets: [] };
            currentBattingTeam = null;
            currentBowlingTeam = null;
            currentBowlerIndex = -1;
            totalOversPerInnings = 0;
            matchState = 'registration';
            firstInningsTotalRuns = 0;
            lastAction = null;
            currentPartnershipRuns = 0; // Reset partnership for new match
            isFreeHit = false; // Reset free hit for new match
            lastCompletedBowlerIndex = -1; // Reset last completed bowler for new match
            tossWinnerName = ''; // NEW: Reset toss winner
            tossDecision = ''; // NEW: Reset toss decision

            // Clear form fields
            teamRegistrationForm.reset();

            // Hide scoreboard and show registration
            hideAllSections(); // Hide all sections first
            teamRegistrationSection.classList.remove('hidden'); // Show registration section
            pastMatchesSection.classList.remove('hidden'); // Ensure past matches section is visible
            showDeveloperInfoBtn.classList.remove('hidden'); // Show developer info button
            newMatchBtn.classList.remove('hidden'); // Ensure new match button is visible
            clearPastMatchesBtn.classList.remove('hidden'); // Ensure clear past matches button is visible
            endMatchBtn.classList.add('hidden'); // Hide end match button on new match
            console.log('newMatch(): End Match button hidden.');


            // Clear scorecards
            liveBatsmanScorecardTable.innerHTML = '';
            liveBowlerScorecardTable.innerHTML = '';
            liveFallOfWicketsList.innerHTML = '';
            liveBatsmanScorecardTeamName.textContent = '';
            liveBowlerScorecardTeamName.textContent = '';
            liveFowTeamName.textContent = '';

            finalTeam1BatsmanScorecardTable.innerHTML = '';
            finalTeam1BowlerScorecardTable.innerHTML = '';
            finalTeam1FOWList.innerHTML = '';
            finalTeam2BatsmanScorecardTable.innerHTML = '';
            finalTeam2BowlerScorecardTable.innerHTML = '';
            finalTeam2FOWList.innerHTML = '';
            finalTeam1NameDisplay.textContent = '';
            finalTeam2NameDisplay.textContent = '';

            pastMatchesList.innerHTML = ''; // Clear past matches list

            // Enable score controls and player selectors
            Array.from(scoreControls.children).forEach(button => button.disabled = false);
            strikerSelect.disabled = false;
            nonStrikerSelect.disabled = false;
            bowlerSelect.disabled = false;
            populatePlayerDropdowns(); // Clear dropdowns

            // showMessageBox('New match started! Please register teams.', 'success'); // Removed this message
            updateScoreboardDisplay(); // Clear scoreboard display and handle info box visibility

            loadPastMatchesLocal(); // Reload past matches after a new match is started
        }

        // Function to render a batsman scorecard for a given team and table element
        function renderBatsmanScorecard(team, targetTable, teamNameElement) {
            targetTable.innerHTML = ''; // Clear previous rows
            if (teamNameElement) teamNameElement.textContent = team ? team.name : '';

            if (team) {
                team.players.forEach((player, index) => {
                    const row = targetTable.insertRow();
                    const nameCell = row.insertCell();
                    const runsCell = row.insertCell();
                    const ballsCell = row.insertCell();
                    const strikeRateCell = row.insertCell(); // New cell for Strike Rate
                    const statusCell = row.insertCell();

                    nameCell.textContent = player.name;
                    runsCell.textContent = player.runsScored;
                    ballsCell.textContent = player.ballsFaced;

                    // Calculate Strike Rate: (Runs / Balls Faced) * 100
                    const strikeRate = player.ballsFaced > 0 ? ((player.runsScored / player.ballsFaced) * 100).toFixed(2) : '0.00';
                    strikeRateCell.textContent = strikeRate;
                    
                    // Determine status based on context (live vs. final scorecard)
                    if (targetTable === liveBatsmanScorecardTable) {
                        statusCell.textContent = player.isOut ? `Out (${team.fallOfWickets.find(fow => fow.batsman === player.name)?.dismissalType || 'N/A'})` : (index === team.currentStrikerIndex ? 'Batting (Striker)' : (index === team.currentNonStrikerIndex ? 'Batting (Non-Striker)' : 'Yet to Bat'));
                        // Highlight current batsmen only in live scorecard
                        if (index === team.currentStrikerIndex || index === team.currentNonStrikerIndex) {
                            row.classList.add('bg-yellow-100');
                        }
                    } else {
                        // Corrected: Changed 'p.name' to 'player.name'
                        statusCell.textContent = player.isOut ? `Out (${team.fallOfWickets.find(fow => fow.batsman === player.name)?.dismissalType || 'N/A'})` : 'Not Out';
                    }

                    runsCell.classList.add('text-right');
                    ballsCell.classList.add('text-right');
                    strikeRateCell.classList.add('text-right'); // Align Strike Rate to right
                });
            }
        }

        // Function to render a bowler scorecard for a given team and table element
        function renderBowlerScorecard(team, targetTable, teamNameElement) {
            targetTable.innerHTML = ''; // Clear previous rows
            if (teamNameElement) teamNameElement.textContent = team ? team.name : '';

            if (team) {
                team.players.forEach((player, index) => {
                    // Only show bowlers who have bowled at least one ball (including extras) or taken a wicket
                    if (player.ballsBowled > 0 || player.wicketsTaken > 0 || player.wides > 0 || player.noBalls > 0) {
                        const row = targetTable.insertRow();
                        const nameCell = row.insertCell();
                        const oversCell = row.insertCell();
                        const runsCell = row.insertCell();
                        const wicketsCell = row.insertCell();
                        const widesCell = row.insertCell();
                        const noBallsCell = row.insertCell();
                        const economyCell = row.insertCell(); // New cell for Economy

                        nameCell.textContent = player.name;
                        oversCell.textContent = `${player.oversBowled}.${player.ballsBowled % 6}`;
                        runsCell.textContent = player.runsConceded;
                        wicketsCell.textContent = player.wicketsTaken;
                        widesCell.textContent = player.wides;
                        noBallsCell.textContent = player.noBalls;

                        // Calculate Economy: Runs Conceded / Total Overs Bowled (including partial overs)
                        const totalBallsBowled = (player.oversBowled * 6) + player.ballsBowled;
                        const economy = totalBallsBowled > 0 ? ((player.runsConceded / totalBallsBowled) * 6).toFixed(2) : '0.00';
                        economyCell.textContent = economy;

                        oversCell.classList.add('text-right');
                        runsCell.classList.add('text-right');
                        wicketsCell.classList.add('text-right');
                        widesCell.classList.add('text-right');
                        noBallsCell.classList.add('text-right');
                        economyCell.classList.add('text-right'); // Align Economy to right

                        // Highlight current bowler only in live scorecard
                        if (targetTable === liveBowlerScorecardTable && index === currentBowlerIndex) {
                            row.classList.add('bg-green-100');
                        }
                    }
                });
            }
        }

        // Function to render fall of wickets for a given team and list element
        function renderFallOfWickets(team, targetList, teamNameElement) {
            targetList.innerHTML = ''; // Clear previous entries
            if (teamNameElement) teamNameElement.textContent = team ? team.name : '';

            if (team && team.fallOfWickets.length > 0) {
                team.fallOfWickets.forEach(fow => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `${fow.batsman} out (${fow.dismissalType}) at ${fow.score} in ${fow.over} overs`;
                    targetList.appendChild(listItem);
                });
            } else {
                const listItem = document.createElement('li');
                    listItem.textContent = 'No wickets yet.';
                    targetList.appendChild(listItem);
            }
        }

        // Function to render all final scorecards after the match ends
        function renderFinalScorecards() {
            // Retrieve the last saved match data to ensure we display the correct summary
            const storedMatches = JSON.parse(localStorage.getItem('cricketMatches')) || [];
            const lastMatch = storedMatches.length > 0 ? storedMatches[0] : null;

            if (!lastMatch) {
                console.warn("No last match data found to render final scorecards.");
                return;
            }

            finalTeam1NameDisplay.textContent = lastMatch.team1.name;
            finalTeam2NameDisplay.textContent = lastMatch.team2.name;

            // Use the data from lastMatch for rendering
            renderBatsmanScorecard(lastMatch.team1, finalTeam1BatsmanScorecardTable);
            renderBowlerScorecard(lastMatch.team2, finalTeam1BowlerScorecardTable); // Team 2 bowled to Team 1
            renderFallOfWickets(lastMatch.team1, finalTeam1FOWList);

            renderBatsmanScorecard(lastMatch.team2, finalTeam2BatsmanScorecardTable);
            renderBowlerScorecard(lastMatch.team1, finalTeam2BowlerScorecardTable); // Team 1 bowled to Team 2
            renderFallOfWickets(lastMatch.team2, finalTeam2FOWList);

            // Set result and Man of the Match from the saved data
            manOfTheMatchPlayer.textContent = lastMatch.manOfTheMatch;
            matchResultDisplay.classList.remove('hidden'); // Already visible, but ensure
            manOfTheMatchDisplay.classList.remove('hidden');
            finalScorecardsSection.classList.remove('hidden');
        }

        // Function to save match details to localStorage
        function saveMatchDetailsLocal(resultMessage, manOfTheMatchName) {
            try {
                // Get existing matches or initialize an empty array
                const existingMatches = JSON.parse(localStorage.getItem('cricketMatches')) || [];

                const matchData = {
                    timestamp: new Date().toISOString(), // Store as ISO string for easy parsing
                    matchDate: document.getElementById('matchDate').value, // Get match date
                    matchTime: document.getElementById('matchTime').value, // Get match time
                    team1: {
                        name: team1.name,
                        runs: team1.runs,
                        wickets: team1.wickets,
                        overs: team1.overs,
                        balls: team1.balls,
                        totalExtras: team1.totalWides + team1.totalNoBalls + team1.totalByes + team1.totalLegByes,
                        players: team1.players.map(player => ({
                            name: player.name,
                            runsScored: player.runsScored,
                            ballsFaced: player.ballsFaced,
                            isOut: player.isOut,
                            wicketsTaken: player.wicketsTaken,
                            runsConceded: player.runsConceded,
                            ballsBowled: player.ballsBowled,
                            wides: player.wides,
                            noBalls: player.noBalls,
                            oversBowled: player.oversBowled
                        })),
                        fallOfWickets: team1.fallOfWickets
                    },
                    team2: {
                        name: team2.name,
                        runs: team2.runs,
                        wickets: team2.wickets,
                        overs: team2.overs,
                        balls: team2.balls,
                        totalWides: team2.totalWides,
                        totalNoBalls: team2.totalNoBalls,
                        totalByes: team2.totalByes,
                        totalLegByes: team2.totalLegByes,
                        totalExtras: team2.totalWides + team2.totalNoBalls + team2.totalByes + team2.totalLegByes,
                        players: team2.players.map(player => ({
                            name: player.name,
                            runsScored: player.runsScored,
                            ballsFaced: player.ballsFaced,
                            isOut: player.isOut,
                            wicketsTaken: player.wicketsTaken,
                            runsConceded: player.runsConceded,
                            ballsBowled: player.ballsBowled,
                            wides: player.wides,
                            noBalls: player.noBalls,
                            oversBowled: player.oversBowled
                        })),
                        fallOfWickets: team2.fallOfWickets
                    },
                    totalOversPerInnings: totalOversPerInnings,
                    firstInningsTotalRuns: firstInningsTotalRuns,
                    result: resultMessage,
                    manOfTheMatch: manOfTheMatchName,
                    tossWinnerName: tossWinnerName, // Save toss winner for historical record
                    tossDecision: tossDecision // Save toss decision for historical record
                };

                existingMatches.unshift(matchData); // Add new match to the beginning
                localStorage.setItem('cricketMatches', JSON.stringify(existingMatches));
                showMessageBox('Match details saved to local storage!', 'success');
                loadPastMatchesLocal(); // Reload past matches to include the newly saved one

            } catch (e) {
                console.error("Error saving match details to local storage: ", e);
                showMessageBox('Failed to save match details to local storage.', 'error');
            }
        }

        // Function to load and display past matches from localStorage
        function loadPastMatchesLocal() {
            pastMatchesList.innerHTML = ''; // Clear existing list

            try {
                const storedMatches = JSON.parse(localStorage.getItem('cricketMatches')) || [];

                if (storedMatches.length === 0) {
                    const listItem = document.createElement('li');
                    listItem.textContent = 'No past matches recorded yet.';
                    pastMatchesList.appendChild(listItem);
                    return;
                }

                storedMatches.forEach((match) => {
                    const listItem = document.createElement('li');
                    // Use matchDate and matchTime if available, otherwise fallback to timestamp
                    const displayDateTime = match.matchDate && match.matchTime
                        ? `${match.matchDate} at ${match.matchTime}`
                        : new Date(match.timestamp).toLocaleString();

                    // Include toss info if available
                    const tossInfo = match.tossWinnerName && match.tossDecision
                        ? `<p class="text-md text-gray-700 mb-2">${match.tossWinnerName} won the toss and chose to ${match.tossDecision} first.</p>`
                        : '';

                    // Create detailed HTML for each past match
                    listItem.innerHTML = `
                        <h4 class="text-lg font-bold text-gray-800">${match.team1.name} vs ${match.team2.name}</h4>
                        <p class="text-md text-gray-700 mb-2">Date & Time: ${displayDateTime}</p>
                        ${tossInfo}
                        <p class="text-md text-gray-700 mb-2">${match.result}</p>
                        <p class="text-md text-gray-700 mb-2">Man of the Match: ${match.manOfTheMatch}</p>
                        <div class="past-match-details">
                            <div class="card">
                                <h5>${match.team1.name} Scorecard</h5>
                                <p>Runs: ${match.team1.runs}/${match.team1.wickets} (${match.team1.overs}.${match.team1.balls} Overs)</p>
                                <p>Extras: ${match.team1.totalExtras}</p>
                                <h6>Batsmen:</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>R</th><th>B</th><th>SR</th><th>Status</th></tr></thead>
                                        <tbody>
                                            ${match.team1.players.map(p => {
                                                const sr = p.ballsFaced > 0 ? ((p.runsScored / p.ballsFaced) * 100).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.runsScored}</td><td class="text-right">${p.ballsFaced}</td><td class="text-right">${sr}</td><td>${p.isOut ? `Out (${match.team1.fallOfWickets.find(fow => fow.batsman === p.name)?.dismissalType || 'N/A'})` : 'Not Out'}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Bowlers (${match.team2.name}):</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>O</th><th>R</th><th>W</th><th>WD</th><th>NB</th><th>Econ</th></tr></thead>
                                        <tbody>
                                            ${match.team2.players.filter(p => p.ballsBowled > 0 || p.wicketsTaken > 0 || p.wides > 0 || p.noBalls > 0).map(p => {
                                                const totalBallsBowled = (p.oversBowled * 6) + p.ballsBowled;
                                                const econ = totalBallsBowled > 0 ? ((p.runsConceded / totalBallsBowled) * 6).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.oversBowled}.${p.ballsBowled % 6}</td><td class="text-right">${p.runsConceded}</td><td class="text-right">${p.wicketsTaken}</td><td class="text-right">${p.wides}</td><td class="text-right">${p.noBalls}</td><td class="text-right">${econ}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Fall of Wickets:</h6>
                                <ul>
                                    ${match.team1.fallOfWickets.map(fow => `<li>${fow.batsman} out (${fow.dismissalType}) at ${fow.score} in ${fow.over} overs</li>`).join('') || '<li>No wickets.</li>'}
                                </ul>
                            </div>
                            <div class="card">
                                <h5>${match.team2.name} Scorecard</h5>
                                <p>Runs: ${match.team2.runs}/${match.team2.wickets} (${match.team2.overs}.${match.team2.balls} Overs)</p>
                                <p>Extras: ${match.team2.totalExtras}</p>
                                <h6>Batsmen:</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>R</th><th>B</th><th>SR</th><th>Status</th></tr></thead>
                                        <tbody>
                                            ${match.team2.players.map(p => {
                                                const sr = p.ballsFaced > 0 ? ((p.runsScored / p.ballsFaced) * 100).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.runsScored}</td><td class="text-right">${p.ballsFaced}</td><td class="text-right">${sr}</td><td>${p.isOut ? `Out (${match.team2.fallOfWickets.find(fow => fow.batsman === p.name)?.dismissalType || 'N/A'})` : 'Not Out'}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Bowlers (${match.team1.name}):</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>O</th><th>R</th><th>W</th><th>WD</th><th>NB</th><th>Econ</th></tr></thead>
                                        <tbody>
                                            ${match.team1.players.filter(p => p.ballsBowled > 0 || p.wicketsTaken > 0 || p.wides > 0 || p.noBalls > 0).map(p => {
                                                const totalBallsBowled = (p.oversBowled * 6) + p.ballsBowled;
                                                const econ = totalBallsBowled > 0 ? ((p.runsConceded / totalBallsBowled) * 6).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.oversBowled}.${p.ballsBowled % 6}</td><td class="text-right">${p.runsConceded}</td><td class="text-right">${p.wicketsTaken}</td><td class="text-right">${p.wides}</td><td class="text-right">${p.noBalls}</td><td class="text-right">${econ}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Fall of Wickets:</h6>
                                <ul>
                                    ${match.team2.fallOfWickets.map(fow => `<li>${fow.batsman} out (${fow.dismissalType}) at ${fow.score} in ${fow.over} overs</li>`).join('') || '<li>No wickets.</li>'}
                                </ul>
                            </div>
                        </div>
                    `;
                    pastMatchesList.appendChild(listItem);
                });
            } catch (e) {
                console.error("Error loading documents from local storage: ", e);
                showMessageBox('Failed to load past match details from local storage.', 'error');
            }
        }

        // Function to clear all past matches from localStorage
        function clearAllPastMatches() {
            // Using a custom modal instead of alert/confirm
            showConfirmationModal('Are you sure you want to clear all past match data? This action cannot be undone.',
                () => {
                    localStorage.removeItem('cricketMatches');
                    pastMatchesList.innerHTML = '<li class="text-gray-600">No past matches recorded yet.</li>';
                    showMessageBox('All past match data cleared!', 'success');
                },
                () => {
                    showMessageBox('Clear operation cancelled.', 'info');
                }
            );
        }

        // NEW: Function to populate toss dropdowns
        function populateTossDropdowns() {
            tossWinnerSelect.innerHTML = '<option value="">Select Winning Team</option>';
            const team1Option = document.createElement('option');
            team1Option.value = 'team1';
            team1Option.textContent = team1.name;
            tossWinnerSelect.appendChild(team1Option);

            const team2Option = document.createElement('option');
            team2Option.value = 'team2';
            team2Option.textContent = team2.name;
            tossWinnerSelect.appendChild(team2Option);

            // Restore selected values if loaded from state
            if (tossWinnerName) {
                tossWinnerSelect.value = tossWinnerName === team1.name ? 'team1' : 'team2';
            }
            if (tossDecision) {
                tossDecisionSelect.value = tossDecision;
            }
        }


        // Event listener for team registration form submission
        teamRegistrationForm.addEventListener('submit', async function(event) {
            event.preventDefault(); // Prevent default form submission

            try {
                // Get team names
                const team1Name = document.getElementById('team1Name').value.trim();
                const team2Name = document.getElementById('team2Name').value.trim();
                const oversInput = document.getElementById('totalOvers').value;
                const matchDate = document.getElementById('matchDate').value;
                const matchTime = document.getElementById('matchTime').value;


                // Get player lists and split by new line
                const team1PlayersRaw = document.getElementById('team1Players').value.trim();
                const team2PlayersRaw = document.getElementById('team2Players').value.trim();

                // Basic validation
                if (!team1Name || !team2Name || !oversInput || !matchDate || !matchTime) {
                    showMessageBox('Please fill in all required fields.', 'error');
                    return;
                }
                if (!team1PlayersRaw || !team2PlayersRaw) {
                    showMessageBox('Please enter players for both teams.', 'error');
                    return;
                }

                totalOversPerInnings = parseInt(oversInput, 10);
                if (isNaN(totalOversPerInnings) || totalOversPerInnings <= 0) {
                    showMessageBox('Please enter a valid number for total overs (greater than 0).', 'error');
                    return;
                }

                // Populate team objects and initialize player stats
                team1.name = team1Name;
                team1.players = team1PlayersRaw.split('\n').map(p => p.trim()).filter(p => p).map(name => ({
                    name: name,
                    runsScored: 0,
                    ballsFaced: 0,
                    isOut: false,
                    wicketsTaken: 0,
                    runsConceded: 0,
                    ballsBowled: 0,
                    wides: 0,
                    noBalls: 0,
                    oversBowled: 0 // Track full overs bowled by bowler
                }));

                team2.name = team2Name;
                team2.players = team2PlayersRaw.split('\n').map(p => p.trim()).filter(p => p).map(name => ({
                    name: name,
                    runsScored: 0,
                    ballsFaced: 0,
                    isOut: false,
                    wicketsTaken: 0,
                    runsConceded: 0,
                    ballsBowled: 0,
                    wides: 0,
                    noBalls: 0,
                    oversBowled: 0
                }));

                // Set match state to 'toss' after successful registration
                matchState = 'toss';

                // Hide registration and show toss section
                hideAllSections(); // Hide all sections
                tossSection.classList.remove('hidden'); // Show toss section
                showDeveloperInfoBtn.classList.remove('hidden'); // Ensure developer info button is visible
                newMatchBtn.classList.remove('hidden'); // New match button visible
                clearPastMatchesBtn.classList.remove('hidden'); // Clear past matches button visible

                populateTossDropdowns(); // Populate toss dropdowns with team names

                showMessageBox('Teams registered! Now perform the toss.', 'success');
                saveCurrentMatchStateToLocal(); // Save current state after registration
            } catch (error) {
                console.error('Error registering teams:', error);
                showMessageBox('An error occurred during team registration. Please try again.', 'error');
            }
        });

        // NEW: Event listener for Proceed to Match Ready button
        proceedToMatchReadyBtn.addEventListener('click', () => {
            const selectedTossWinner = tossWinnerSelect.value;
            const selectedTossDecision = tossDecisionSelect.value;

            if (!selectedTossWinner || !selectedTossDecision) {
                showMessageBox('Please select both toss winner and their decision.', 'error');
                return;
            }

            tossWinnerName = (selectedTossWinner === 'team1') ? team1.name : team2.name;
            tossDecision = selectedTossDecision;

            // Determine initial batting and bowling teams based on toss
            if (selectedTossWinner === 'team1') {
                if (selectedTossDecision === 'bat') {
                    currentBattingTeam = team1;
                    currentBowlingTeam = team2;
                } else { // bowl
                    currentBattingTeam = team2;
                    currentBowlingTeam = team1;
                }
            } else { // team2 won toss
                if (selectedTossDecision === 'bat') {
                    currentBattingTeam = team2;
                    currentBowlingTeam = team1;
                } else { // bowl
                    currentBattingTeam = team1;
                    currentBowlingTeam = team2;
                }
            }

            matchState = 'teams_registered'; // Set match state to teams_registered after toss

            hideAllSections();
            matchReadySection.classList.remove('hidden');
            registeredTeamsSummary.textContent = `${team1.name} vs ${team2.name} (${totalOversPerInnings} Overs per innings) on ${document.getElementById('matchDate').value} at ${document.getElementById('matchTime').value}. ${tossWinnerName} won the toss and chose to ${tossDecision} first.`;
            showDeveloperInfoBtn.classList.remove('hidden');
            newMatchBtn.classList.remove('hidden');
            clearPastMatchesBtn.classList.remove('hidden');
            endMatchBtn.classList.add('hidden');

            showMessageBox('Toss completed! Match ready to start.', 'success');
            saveCurrentMatchStateToLocal();
        });


        // Event listener for Start Match button
        startMatchBtn.addEventListener('click', async () => {
            if (matchState === 'teams_registered') {
                matchState = 'innings1'; // Set match state to first innings

                // Set initial batsmen for the current batting team (determined by toss)
                if (currentBattingTeam.players.length >= 2) {
                    currentBattingTeam.currentStrikerIndex = 0;
                    currentBattingTeam.currentNonStrikerIndex = 1;
                } else if (currentBattingTeam.players.length === 1) {
                    currentBattingTeam.currentStrikerIndex = 0;
                    currentBattingTeam.currentNonStrikerIndex = -1;
                } else {
                    showMessageBox(`${currentBattingTeam.name} needs at least one player to start.`, 'error');
                    return;
                }

                hideAllSections(); // Hide all sections
                scoreboardSection.classList.remove('hidden'); // Show scoreboard
                showDeveloperInfoBtn.classList.remove('hidden'); // Ensure developer info button is visible
                endMatchBtn.classList.add('hidden'); // Hide end match button at start
                newMatchBtn.classList.add('hidden'); // Hide new match button during innings
                console.log('startMatchBtn click: End Match button hidden.');

                updateScoreboardDisplay();
                showMessageBox('Match started!', 'success');
                saveCurrentMatchStateToLocal(); // Save initial match state to local storage
            } else {
                showMessageBox('Teams are not registered yet or toss is not completed.', 'error');
            }
        });


        // Add event listeners for score control buttons
        add1RunBtn.addEventListener('click', () => addRuns(1));
        add2RunsBtn.addEventListener('click', () => addRuns(2));
        add4RunsBtn.addEventListener('click', () => addRuns(4));
        add6RunsBtn.addEventListener('click', () => addRuns(6));
        // New Wicket Buttons
        addCaughtBtn.addEventListener('click', () => addWicket('Caught'));
        addBowledLbwBtn.addEventListener('click', () => addWicket('Bowled/LBW'));
        addRunOutBtn.addEventListener('click', () => addWicket('Run Out'));
        addStumpedBtn.addEventListener('click', () => addWicket('Stumped'));
        addHitWicketBtn.addEventListener('click', () => addWicket('Hit Wicket'));
        addOtherWicketBtn.addEventListener('click', () => addWicket('Other'));

        addBallBtn.addEventListener('click', addBall);
        addWideBtn.addEventListener('click', addWide);
        addNoBallBtn.addEventListener('click', addNoBall);
        addByeBtn.addEventListener('click', addBye);
        addLegByeBtn.addEventListener('click', addLegBye);
        switchStrikeBtn.addEventListener('click', switchStrike);
        undoBtn.addEventListener('click', undoLastAction);
        switchTeamBtn.addEventListener('click', switchBattingTeam);
        newMatchBtn.addEventListener('click', newMatch);
        clearPastMatchesBtn.addEventListener('click', clearAllPastMatches); // New button listener
        endMatchBtn.addEventListener('click', () => {
            console.log('End Match button clicked.');
            // When End Match button is clicked, ensure final scorecards are shown
            if (matchState === 'completed') {
                hideAllSections();
                scoreboardSection.classList.remove('hidden'); // Show the scoreboard section (which contains summary)
                renderFinalScorecards(); // This will now explicitly show the summary elements
                endMatchBtn.classList.add('hidden'); // Hide end match button after click
                newMatchBtn.classList.remove('hidden'); // Keep new match button visible
                // Controls are already disabled by declareWinner
                updateScoreboardDisplay(); // Call updateScoreboardDisplay again to hide live info boxes
            } else {
                showMessageBox('Match is not yet completed.', 'error');
            }
        });

        // Event listeners for Developer Info page (NEW)
        // Add a button to the main app container to show developer info
        const developerInfoButtonContainer = document.createElement('div');
        developerInfoButtonContainer.className = 'flex justify-center mt-8'; // Changed from text-center to flex justify-center
        developerInfoButtonContainer.innerHTML = '<button id="showDeveloperInfoBtn">Developer Info</button>';
        document.querySelector('.app-container').appendChild(developerInfoButtonContainer);
        showDeveloperInfoBtn = document.getElementById('showDeveloperInfoBtn'); // Assign to the global variable

        showDeveloperInfoBtn.addEventListener('click', () => {
            hideAllSections();
            developerInfoSection.classList.remove('hidden');
            showDeveloperInfoBtn.classList.add('hidden'); // Hide the button when on this page
            newMatchBtn.classList.remove('hidden'); // Ensure new match button is visible on dev info page
            clearPastMatchesBtn.classList.remove('hidden'); // Ensure clear past matches button is visible
        });

        backToMainBtn.addEventListener('click', () => {
            hideAllSections();
            // Determine which section to show based on the current match state
            if (matchState === 'registration') {
                teamRegistrationSection.classList.remove('hidden');
                pastMatchesSection.classList.remove('hidden');
                newMatchBtn.classList.remove('hidden');
                clearPastMatchesBtn.classList.remove('hidden');
                endMatchBtn.classList.add('hidden'); // Ensure hidden
            } else if (matchState === 'toss') {
                tossSection.classList.remove('hidden');
                pastMatchesSection.classList.remove('hidden');
                newMatchBtn.classList.remove('hidden');
                clearPastMatchesBtn.classList.remove('hidden');
                endMatchBtn.classList.add('hidden'); // Ensure hidden
            } else if (matchState === 'teams_registered') {
                matchReadySection.classList.remove('hidden');
                pastMatchesSection.classList.remove('hidden');
                newMatchBtn.classList.remove('hidden');
                clearPastMatchesBtn.classList.remove('hidden');
                endMatchBtn.classList.add('hidden'); // Ensure hidden
            } else if (matchState === 'innings1' || matchState === 'innings2') {
                scoreboardSection.classList.remove('hidden');
                newMatchBtn.classList.add('hidden'); // Hide new match button during innings
                endMatchBtn.classList.add('hidden'); // Hide end match button during innings
            } else if (matchState === 'completed') {
                scoreboardSection.classList.remove('hidden');
                // If returning to a completed match, show the immediate result and New Match button
                matchResultDisplay.classList.remove('hidden');
                manOfTheMatchDisplay.classList.remove('hidden'); // Show MOTM and final scorecards
                finalScorecardsSection.classList.remove('hidden');
                endMatchBtn.classList.add('hidden'); // Hide end match button as summary is already shown
                newMatchBtn.classList.remove('hidden'); // Show new match button
            }
            showDeveloperInfoBtn.classList.remove('hidden'); // Show the button when returning to main sections
            updateScoreboardDisplay(); // Ensure info boxes are correctly hidden/shown
        });


        // Initial load of past matches and current match state when the page loads
        window.onload = () => {
            loadCurrentMatchStateFromLocal(); // Attempt to load current match state first
            loadPastMatchesLocal(); // Always load past matches on startup
        };
    </script>
</body>
</html>
