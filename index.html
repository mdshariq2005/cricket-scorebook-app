<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scorebook</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0f2f7; /* Lighter blue-gray background for a fresh feel */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to start for better scrolling on small screens */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        /* Container for the app to center it on larger screens and provide padding */
        .app-container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15); /* More pronounced shadow */
            padding: 1.5rem; /* Reduced default padding for smaller screens */
            width: 100%;
            max-width: 950px; /* Slightly increased max width */
            margin-top: 20px; /* Space from top */
        }
        @media (min-width: 768px) { /* md breakpoint in Tailwind */
            .app-container {
                padding: 2.5rem; /* Restore larger padding for larger screens */
            }
        }
        /* Style for form labels */
        label {
            display: block;
            /* Removed margin-bottom here to allow for more granular control with Tailwind classes */
            font-weight: 600;
            color: #2d3748; /* Darker text for labels */
        }
        /* Style for input fields, textareas, and selects */
        input[type="text"],
        input[type="number"],
        input[type="date"], /* Added style for date input */
        input[type="time"], /* Added style for time input */
        textarea,
        select {
            width: 100%;
            padding: 0.75rem 1.5rem; /* Reduced padding for smaller inputs */
            /* Removed margin-bottom here to allow for more granular control with Tailwind classes */
            border: 1px solid #cbd5e1; /* Light gray border */
            border-radius: 0.75rem; /* More rounded corners for inputs */
            font-size: 0.95rem; /* Slightly smaller font size for readability */
            box-sizing: border-box; /* Include padding in width */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            text-align: center; /* Center align text in input boxes */
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus, /* Added focus style for date input */
        input[type="time"]:focus, /* Added focus style for time input */
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #3b82f6; /* Blue border on focus */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); /* Blue ring on focus */
        }
        /* Style for buttons - now unified */
        button {
            background-color: #87CEEB; /* Solid Light blue background (SkyBlue) */
            color: #1a202c; /* Black text */
            padding: 0.6rem 1.2rem; /* Reduced default padding for a more balanced look */
            border-radius: 0.5rem; /* Equivalent to rounded-lg */
            font-weight: 700; /* Bold */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Equivalent to shadow-lg */
            border: 1px solid #6495ED; /* Subtle border matching a slightly darker light blue */
            box-sizing: border-box; /* Ensure padding is included in element's total width and height */
            /* These properties center the *content* inside the button */
            display: flex;
            justify-content: center;
            align-items: center;
            /* Removed: white-space: nowrap; */ /* Allow text to wrap */
            text-align: center; /* Ensure text is centered when it wraps */
            /* Removed margin: 0 auto; from here, as parent flex will handle centering */
        }
        button:hover {
            background-color: #6495ED; /* Slightly darker light blue on hover */
            transform: translateY(-1px);
            box-shadow: 0 15px 20px -5px rgba(0, 0, 0, 0.15), 0 6px 8px -3px rgba(0, 0, 0, 0.08); /* Slightly more pronounced shadow on hover */
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:disabled {
            background-color: #e2e8f0; /* Lighter gray out disabled buttons */
            color: #94a3b8; /* Lighter text for disabled */
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
            border-color: #cbd5e1; /* Match border to background */
        }
        /* Specific padding for larger primary action buttons */
        #teamRegistrationForm button[type="submit"],
        #proceedToMatchReadyBtn,
        #startMatchBtn,
        #newMatchBtn,
        #clearPastMatchesBtn,
        #developerInfoBtn, /* Changed from showDeveloperInfoBtn */
        #restartMatchBtn, /* Added restart button */
        #cancelMatchBtn, /* Added cancel button */
        #confirmationModal button, /* Apply base button style to modal buttons */
        #cancelReasonModal button, /* Apply base button style to cancel reason modal buttons */
        #confirmPlayingXIBtn, /* Apply base button style to playing XI confirmation button */
        #backBtnPlayingXI, /* Apply base button style to the new back button */
        #backBtnToss, /* Apply base button style to the new back button */
        #backBtnMatchReady, /* Apply base button style to the new back button */
        #backBtnMatchSummary, /* Apply base button style to the new back button */
        #backBtnDeveloperInfo, /* Apply base button style to the new back button */
        #wideExtraRunsModal button, /* Apply base button style to wide extra runs modal buttons */
        #noBallExtraRunsModal button, /* NEW: Apply base button style to no ball extra runs modal buttons */
        #fielderSelectionModal button, /* Apply base button style to fielder selection modal buttons */
        #confirmCaptainWkBtn, /* NEW */
        #backBtnCaptainWk, /* NEW */
        #resetAllBtn /* NEW */
        {
            padding: 0.8rem 2rem; /* Slightly larger padding for main action buttons */
            font-size: 0.9rem; /* Slightly larger font for main action buttons */
        }

        /* Ensure score control buttons maintain their size or inherit the new default */
        .score-control-button {
            padding: 0.5rem 1rem; /* Slightly smaller padding for score controls */
        }

        /* Message box styling */
        .message-box {
            position: fixed;
            top: 20px; /* Distance from top */
            right: 20px; /* Distance from right */
            transform: translateX(100%); /* Start off-screen to the right */
            background-color: #10b981; /* Green for success */
            color: white;
            padding: 1.2rem 2.5rem; /* More padding */
            border-radius: 1rem; /* More rounded */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25); /* Stronger shadow */
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
            text-align: center;
            font-size: 1.1rem; /* Slightly larger font */
            font-weight: 500;
        }
        .message-box.show {
            opacity: 1;
            transform: translateX(0) scale(1); /* Slide in from right */
        }
        .message-box.error {
            background-color: #ef4444; /* Red for error */
        }
        /* Scoreboard specific styles */
        .team-score-card {
            background-color: #f8fafc; /* Lighter background */
            border-radius: 1.rem;
            padding: 1.8rem; /* More padding */
            text-align: center;
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.08); /* More subtle inner shadow */
            transition: all 0.3s ease-in-out;
        }
        .team-score-card.active {
            border: 3px solid #3b82f6; /* Thicker, more prominent highlight */
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.6); /* Stronger glow */
            background-color: #e3f2fd; /* Very light blue for active card */
        }
        .team-score-card h3 {
            font-size: 2rem; /* Larger team name */
            font-weight: 800; /* Extra bold */
            color: #1a202c; /* Darker text */
            margin-bottom: 0.8rem;
        }
        .team-score-card p {
            font-size: 1.35rem; /* Slightly larger paragraph text */
            color: #4a5568;
            margin-bottom: 0.6rem;
        }
        .score-display {
            font-size: 4rem; /* Significantly larger score */
            font-weight: 900;
            color: #1a202c;
            line-height: 1;
        }
        .overs-display {
            font-size: 1.8rem; /* Larger overs display */
            font-weight: 700;
            color: #4a5568;
        }
        .match-result {
            margin-top: 2.5rem;
            padding: 1.8rem;
            background-color: #d1fae5; /* Light green for success */
            border-radius: 1rem;
            border: 1px solid #34d399;
            text-align: center;
            font-size: 1.75rem; /* Larger result text */
            font-weight: bold;
            color: #065f46;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            /* Removed: border: 2px solid purple; /* Added for debugging */ */
        }
        .match-result.draw {
            background-color: #bfdbfe; /* Light blue for draw */
            border-color: #60a5fa;
            color: #1e40af;
        }
        /* Table styles for scorecards */
        .scorecard-table {
            width: 100%;
            border-collapse: separate; /* Use separate to allow border-radius on cells */
            border-spacing: 0; /* Remove spacing between cells */
            margin-top: 1.8rem;
            font-size: 0.95rem;
            border-radius: 0.75rem; /* Rounded corners for the whole table */
            overflow: hidden; /* Hide overflowing borders */
        }
        .scorecard-table th, .scorecard-table td {
            border: 1px solid #e2e8f0; /* Lighter border */
            padding: 0.8rem 1rem; /* More padding */
            text-align: left;
        }
        .scorecard-table th {
            background-color: #e2e8f0; /* Light gray header */
            font-weight: 700;
            color: #4a5568;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .scorecard-table tbody tr:nth-child(odd) {
            background-color: #f7fafc; /* Very light alternating rows */
        }
        .scorecard-table tbody tr:hover {
            background-color: #ebf8ff; /* Light blue on hover */
        }
        .scorecard-table td.text-right {
            text-align: right;
        }
        .fall-of-wickets-list {
            list-style: none;
            padding: 0;
            max-height: 180px; /* Slightly taller */
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.2rem;
            background-color: #f7fafc;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            width: 100%; /* Ensure it takes full available width */
            box-sizing: border-box; /* Ensure padding is correctly handled within the width */
            min-width: 0; /* Ensure the ul can shrink */
            /* Removed: background-color: #f0f9ff; /* Temporary: Light blue background for visibility */ */
        }
        .fall-of-wickets-list li {
            padding: 0.6rem 0;
            border-bottom: 1px dashed #e2e8f0;
            color: #4a5568;
            /* Ensure text wraps */
            word-break: break-word; /* Breaks long words if they don't fit */
            overflow-wrap: break-word; /* Modern equivalent */
            white-space: normal; /* Ensure text wraps normally */
            width: 100%; /* Ensure li takes full width of its parent ul */
            box-sizing: border-box; /* Ensure padding is correctly handled */
        }
        .fall-of-wickets-list li:last-child {
            border-bottom: none;
        }
        .man-of-the-match {
            margin-top: 2.5rem;
            padding: 1.8rem;
            background-color: #fffacd; /* Light goldenrod yellow */
            border-radius: 1rem;
            border: 1px solid #fcd34d;
            text-align: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #b45309;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }
        /* Style for past matches section */
        .past-matches-section {
            margin-top: 2.5rem;
            padding: 2rem;
            background-color: #e3f2fd; /* Light blue background */
            border-radius: 1rem;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }
        .past-matches-list {
            list-style: none;
            padding: 0;
        }
        .past-matches-list li {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            min-width: 0; /* Allow shrinking */
        }
        .past-matches-list li:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.12);
        }
        .past-matches-list li h4,
        .past-matches-list li p {
            word-break: break-word;
            overflow-wrap: break-word; /* Modern equivalent */
        }
        .past-match-details {
            display: flex; /* Default to flex column for small screens */
            flex-direction: column;
            gap: 1.5rem; /* Increased gap */
            margin-top: 1.5rem;
        }
        @media (min-width: 768px) { /* md breakpoint in Tailwind */
            .past-match-details {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            }
        }
        .past-match-details .card {
            background-color: #f8fafc;
            border: 1px solid #cbd5e1;
            border-radius: 0.75rem;
            padding: 1.2rem;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            min-width: 0; /* Allow shrinking */
        }
        .past-match-details h5 {
            font-weight: bold;
            margin-bottom: 0.6rem;
            color: #2d3748;
        }
        .past-match-details table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.75rem;
        }
        .past-match-details th, .past-match-details td {
            border: 1px solid #e2e8f0;
            padding: 0.6rem;
            text-align: left;
            font-size: 0.9rem;
        }
        .past-match-details th {
            background-color: #edf2f7;
        }
        .app-logo {
            display: block;
            margin: 0 auto 1.8rem auto; /* Center the logo and add more margin below */
            width: 60px; /* Reduced logo size */
            height: 60px; /* Reduced logo size */
            color: #3b82f6; /* Blue color for the logo */
        }
        /* New styles for team registration form */
        #teamRegistrationSection {
            background-color: #f0f8ff; /* Very light blue background */
            border: 1px solid #e0e7ff; /* Subtle border */
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #teamRegistrationSection h2 {
            font-size: 2.2rem; /* Larger title for emphasis */
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
            text-align: center; /* Center the title */
        }
        /* Updated styling for registration form layout */
        #teamRegistrationForm .grid-cols-1 {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem; /* Increased gap for better spacing */
        }
        @media (min-width: 768px) {
            #teamRegistrationForm .md\:grid-cols-2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        #teamRegistrationForm .form-group {
            margin-bottom: 0; /* Remove default margin as grid handles spacing */
        }
        #teamRegistrationForm label {
            margin-bottom: 0.5rem; /* Space between label and input */
        }
        #teamRegistrationForm textarea {
            min-height: 100px; /* Ensure textarea has a decent starting height */
            resize: vertical; /* Allow vertical resizing */
        }


        /* Styles for the new live score panel */
        .live-score-panel {
            background-color: #f8fafc;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 2rem;
        }

        .score-control-group {
            background-color: #edf2f7;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
        }
        .score-control-group h4 {
            font-weight: 700;
            color: #4a5568;
            margin-bottom: 0.75rem;
            text-align: center;
        }
        .info-panel {
            background-color: #ecfdf5; /* Light green for info */
            border: 1px solid #a7f3d0;
            border-radius: 0.75rem;
            padding: 1rem;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            color: #065f46;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        /* Developer Info Section Specific Styles */
        #developerInfoSection {
            background-color: #f0f8ff;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            text-align: center;
        }
        #developerInfoSection h2 {
            font-size: 2.2rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
        }
        #developerInfoSection p {
            font-size: 1.1rem;
            color: #4a5568;
            margin-bottom: 0.8rem;
        }
        #developerInfoSection .back-button {
            background-color: #87CEEB; /* Solid Light blue background (SkyBlue) */
            border: 1px solid #6495ED; /* Subtle border matching a slightly darker light blue */
            margin-top: 2rem;
        }

        /* Styles for the new Toss Section */
        #tossSection {
            background-color: #f0f8ff;
            border: 1px solid #e0e7ff;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #tossSection h2 {
            font-size: 2.2rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        #tossSection .space-y-4 > div {
            margin-bottom: 1rem;
        }
        /* Removed: #matchResultMessageText { background-color: lightblue; /* Added for debugging */ } */

        /* NEW: Playing XI Selection Section */
        #playingXISelectionSection {
            background-color: #f0f8ff;
            border: 1px solid #e0e7ff;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #playingXISelectionSection h2 {
            font-size: 2.2rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        .player-list-container {
            border: 1px solid #cbd5e1;
            border-radius: 0.75rem;
            padding: 1rem;
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
            background-color: #f8fafc;
        }
        .player-list-container label {
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
            cursor: pointer;
            font-weight: normal; /* Override default label bold */
            color: #4a5568;
        }
        .player-list-container label:hover {
            background-color: #f0f9ff;
        }
        .player-list-container input[type="checkbox"] {
            margin-right: 0.75rem;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 0.25rem;
            border: 1px solid #94a3b8;
            accent-color: #3b82f6; /* Blue checkbox */
        }

        /* NEW: Captain & Wicket Keeper Selection Section */
        #captainWkSelectionSection {
            background-color: #f0f8ff;
            border: 1px solid #e0e7ff;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #captainWkSelectionSection h2 {
            font-size: 2.2rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        #captainWkSelectionSection .space-y-4 > div {
            margin-bottom: 1rem;
        }

        /* Animation for flashing effect */
        .flash-effect {
            animation: flash 0.3s ease-in-out;
        }

        @keyframes flash {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Logo -->
        <div class="text-center mb-6">
            <svg class="app-logo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 2v10"></path>
                <path d="M12 12l4 4"></path>
                <path d="M12 12l-4 4"></path>
                <line x1="12" y1="2" x2="12" y2="22"></line>
                <line x1="2" y1="12" x2="22" y2="12"></line>
            </svg>
        </div>

        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Scorebook</h1>

        <!-- Team Registration Section -->
        <div id="teamRegistrationSection">
            <h2 class="text-2xl font-semibold text-gray-700 mb-6">Team Registration</h2>
            <form id="teamRegistrationForm" class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                <!-- Team 1 Details -->
                <div class="form-group">
                    <label for="team1Name" class="mb-2">Team 1 Name:</label>
                    <input type="text" id="team1Name" name="team1Name" placeholder="e.g., Lions" required class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                </div>
                <div class="form-group">
                    <label for="team1Players" class="mb-2">Team 1 Players (one per line):</label>
                    <textarea id="team1Players" name="team1Players" rows="6" placeholder="Player A&#10;Player B&#10;Player C" class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"></textarea>
                </div>

                <!-- Team 2 Details -->
                <div class="form-group">
                    <label for="team2Name" class="mb-2">Team 2 Name:</label>
                    <input type="text" id="team2Name" name="team2Name" placeholder="e.g., Tigers" required class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                </div>
                <div class="form-group">
                    <label for="team2Players" class="mb-2">Team 2 Players (one per line):</label>
                    <textarea id="team2Players" name="team2Players" rows="6" placeholder="Player X&#10;Player Y&#10;Player Z" class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"></textarea>
                </div>

                <!-- Match Details -->
                <div class="form-group md:col-span-2"> <!-- Spans two columns on medium screens and up -->
                    <label for="totalOvers" class="mb-2">Total Overs per Innings:</label>
                    <input type="number" id="totalOvers" name="totalOvers" placeholder="e.g., 20" min="1" required class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                </div>

                <div class="form-group">
                    <label for="matchDate" class="mb-2">Match Date:</label>
                    <input type="date" id="matchDate" name="matchDate" required class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                </div>
                <div class="form-group">
                    <label for="matchTime" class="mb-2">Match Time:</label>
                    <input type="time" id="matchTime" name="matchTime" required class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                </div>

                <div class="flex justify-center gap-4 mt-6 md:col-span-2"> <!-- Buttons span two columns -->
                    <button type="submit" id="registerTeamsBtn">Register Teams</button>
                    <button type="button" id="resetAllBtn" class="bg-red-500 hover:bg-red-600 text-white">Reset All</button>
                </div>
            </form>
        </div>

        <!-- NEW: Playing XI Selection Section (initially hidden) -->
        <div id="playingXISelectionSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Select Playing XI</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3" id="team1PlayingXITitle">Team 1 Players <span id="team1PlayingXICounter" class="text-sm text-gray-500">(0/11)</span></h3>
                    <div id="team1PlayersList" class="player-list-container">
                        <!-- Checkboxes for Team 1 players will be inserted here -->
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3" id="team2PlayingXITitle">Team 2 Players <span id="team2PlayingXICounter" class="text-sm text-gray-500">(0/11)</span></h3>
                    <div id="team2PlayersList" class="player-list-container">
                        <!-- Checkboxes for Team 2 players will be inserted here -->
                    </div>
                </div>
            </div>
            <div class="flex justify-center gap-4">
                <button id="backBtnPlayingXI">Back</button>
                <button id="confirmPlayingXIBtn">Confirm Playing XI</button>
            </div>
        </div>

        <!-- NEW: Captain & Wicket Keeper Selection Section (initially hidden) -->
        <div id="captainWkSelectionSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Select Captain & Wicket Keeper</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3" id="team1CaptainWkTitle">Team 1 (<span id="displayTeam1NameWk"></span>)</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="team1CaptainSelect">Captain:</label>
                            <select id="team1CaptainSelect" class="w-full"></select>
                        </div>
                        <div>
                            <label for="team1WkSelect">Wicket Keeper:</label>
                            <select id="team1WkSelect" class="w-full"></select>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3" id="team2CaptainWkTitle">Team 2 (<span id="displayTeam2NameWk"></span>)</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="team2CaptainSelect">Captain:</label>
                            <select id="team2CaptainSelect" class="w-full"></select>
                        </div>
                        <div>
                            <label for="team2WkSelect">Wicket Keeper:</label>
                            <select id="team2WkSelect" class="w-full"></select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex justify-center gap-4">
                <button id="backBtnCaptainWk">Back</button>
                <button id="confirmCaptainWkBtn">Confirm Captain & WK</button>
            </div>
        </div>


        <!-- Toss Section (NEW - initially hidden) -->
        <div id="tossSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Match Toss</h2>
            <div class="space-y-4">
                <div>
                    <label for="tossWinner">Who won the toss?</label>
                    <select id="tossWinner" required>
                        <option value="">Select Winning Team</option>
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <label for="tossDecision">Decision:</label>
                    <select id="tossDecision" required>
                        <option value="">Select Decision</option>
                        <option value="bat">Bat First</option>
                        <option value="bowl">Bowl First</option>
                    </select>
                </div>
                <div class="flex justify-center gap-4"> <!-- Added gap-4 for spacing -->
                    <button id="backBtnToss">Back</button>
                    <button id="proceedToMatchReadyBtn">Proceed to Match Ready</button>
                </div>
            </div>
        </div>


        <!-- Match Ready Section (initially hidden) -->
        <div id="matchReadySection" class="hidden bg-blue-50 p-6 rounded-lg shadow-md text-center mt-8">
            <h2 class="text-xl font-semibold text-blue-800 mb-4">Match Ready!</h2>
            <p id="registeredTeamsSummary" class="text-lg text-blue-700 mb-6"></p>
            <div class="flex justify-center gap-4"> <!-- Added gap-4 for spacing -->
                <button id="backBtnMatchReady">Back</button>
                <button id="startMatchBtn">Start Match</button>
            </div>
        </div>

        <!-- Scoreboard Section (initially hidden) -->
        <div id="scoreboardSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">Live Score</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <!-- Team 1 Score Card -->
                <div id="team1Card" class="team-score-card">
                    <h3 id="displayTeam1Name">Team 1</h3>
                    <p class="score-display"><span id="team1Runs">0</span>/<span id="team1Wickets">0</span></p>
                    <p class="overs-display">Overs: <span id="team1Overs">0.0</span></p>
                    <p class="text-sm text-gray-500">Extras: <span id="team1Extras">0</span></p>
                </div>

                <!-- Team 2 Score Card -->
                <div id="team2Card" class="team-score-card">
                    <h3 id="displayTeam2Name">Team 2</h3>
                    <p class="score-display"><span id="team2Runs">0</span>/<span id="team2Wickets">0</span></p>
                    <p class="overs-display">Overs: <span id="team2Overs">0.0</span></p>
                    <p class="text-sm text-gray-500">Extras: <span id="team2Extras">0</span></p>
                </div>
            </div>

            <div class="mb-6 text-center">
                <p class="text-xl font-bold text-gray-800" id="currentBattingTeamContainer">Current Batting: <span id="currentBattingTeam"></span></p>
                <p class="text-lg text-gray-600" id="oversRemainingContainer">Overs Remaining: <span id="oversRemaining">N/A</span></p>
                <p class="text-lg text-gray-600" id="tossInfoDisplay">Toss: <span id="tossWinnerInfo"></span> won the toss and chose to <span id="tossDecisionInfo"></span> first.</p> <!-- NEW TOSS INFO DISPLAY -->
                <p class="text-lg text-gray-600 hidden" id="targetScoreDisplay">Target: <span id="targetScore">0</span> runs</p>
                <p class="text-lg font-bold text-red-600 mt-2 hidden" id="freeHitDisplay">FREE HIT!</p>

                <!-- NEW: Runs, Balls, Wickets Remaining for Chasing Team -->
                <div id="chasingInfoDisplay" class="hidden mt-4 text-lg text-gray-700">
                    <p><span id="runsRequired">0</span> runs needed from <span id="ballsRemaining">0</span> balls with <span id="wicketsRemaining">0</span> wickets remaining.</p>
                </div>
            </div>

            <!-- New Live Score Panel for controls and info -->
            <div class="live-score-panel">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <!-- Current Over and Partnership Info -->
                    <div class="info-panel" id="currentOverInfoPanel">
                        Current Over: <span id="currentOverBallsDisplay">0</span> balls
                    </div>
                    <div class="info-panel" id="partnershipInfoPanel">
                        Partnership: <span id="partnershipRunsDisplay">0</span> runs
                    </div>
                </div>

                <!-- Player Selection Dropdowns -->
                <div id="playerSelection" class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                    <div>
                        <label for="strikerSelect" class="block mb-1">Striker:</label>
                        <select id="strikerSelect"></select>
                    </div>
                    <div>
                        <label for="nonStrikerSelect" class="block mb-1">Non-Striker:</label>
                        <select id="nonStrikerSelect"></select>
                    </div>
                    <div>
                        <label for="bowlerSelect" class="block mb-1">Current Bowler:</label>
                        <select id="bowlerSelect"></select>
                    </div>
                </div>

                <!-- Score Control Buttons -->
                <div id="scoreControls" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Runs Group -->
                    <div class="score-control-group">
                        <h4>Runs</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="add1RunBtn" class="score-control-button">1 Run</button>
                            <button id="add2RunsBtn" class="score-control-button">2 Runs</button>
                            <button id="add4RunsBtn" class="score-control-button">4 Runs</button>
                            <button id="add6RunsBtn" class="score-control-button">6 Runs</button>
                        </div>
                    </div>

                    <!-- Wickets & Balls Group -->
                    <div class="score-control-group">
                        <h4>Wickets</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="addCaughtBtn" class="score-control-button">Caught</button>
                            <button id="addBowledLbwBtn" class="score-control-button">Bowled/LBW</button>
                            <button id="addRunOutBtn" class="score-control-button">Run Out</button>
                            <button id="addStumpedBtn" class="score-control-button">Stumped</button>
                            <button id="addHitWicketBtn" class="score-control-button">Hit Wicket</button>
                            <button id="addOtherWicketBtn" class="score-control-button">Other Wicket</button>
                        </div>
                    </div>

                    <!-- Extras Group -->
                    <div class="score-control-group">
                        <h4>Extras & Balls</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="addWideBtn" class="score-control-button">Wide</button>
                            <button id="addNoBallBtn" class="score-control-button">No Ball</button>
                            <button id="addByeBtn" class="score-control-button">Bye</button>
                            <button id="addLegByeBtn" class="score-control-button">Leg Bye</button>
                            <button id="addBallBtn" class="score-control-button">Dot Ball</button>
                        </div>
                    </div>

                    <!-- Utility Controls (full width on smaller screens) -->
                    <div class="score-control-group md:col-span-2 lg:col-span-3">
                        <h4>Match Controls</h4>
                        <div class="flex flex-wrap justify-center gap-2">
                            <button id="switchStrikeBtn" class="score-control-button">Switch Strike</button>
                            <button id="undoBtn" class="score-control-button">Undo Last</button>
                            <button id="switchTeamBtn" class="score-control-button">Switch Batting Team</button>
                            <button id="cancelMatchBtn" class="score-control-button bg-red-500 text-white hover:bg-red-600">Cancel Match</button> <!-- NEW -->
                        </div>
                    </div>
                </div>
            </div>


            <!-- Scorecards Section (Live) -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-8" id="liveScorecards">
                <!-- Batsman Scorecard (Live) -->
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Batsman Scorecard (<span id="batsmanScorecardTeamName"></span>)</h3>
                    <div class="overflow-x-auto">
                        <table id="batsmanScorecard" class="scorecard-table">
                            <thead>
                                <tr>
                                    <th>Batsman</th>
                                    <th class="text-right">Runs</th>
                                    <th class="text-right">Balls</th>
                                    <th class="text-right">SR</th> <!-- Added Strike Rate header -->
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Batsman rows will be inserted here by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Bowler Scorecard (Live) -->
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Bowler Scorecard (<span id="bowlerScorecardTeamName"></span>)</h3>
                    <div class="overflow-x-auto">
                        <table id="bowlerScorecard" class="scorecard-table">
                            <thead>
                                <tr>
                                    <th>Bowler</th>
                                    <th class="text-right">Overs</th>
                                    <th class="text-right">Runs</th>
                                    <th class="text-right">Wickets</th>
                                    <th class="text-right">WD</th>
                                    <th class="text-right">NB</th>
                                    <th class="text-right">Econ</th> <!-- Added Economy header -->
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Bowler rows will be inserted here by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Fall of Wickets Section (Live) -->
            <div class="mt-8 min-w-0" id="liveFOW"> <!-- Added min-w-0 here -->
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Fall of Wickets (<span id="fowTeamName"></span>)</h3>
                <ul id="fallOfWicketsList" class="fall-of-wickets-list">
                    <!-- Fall of wickets will be inserted here by JavaScript -->
                </ul>
            </div>

            <!-- Match Result Display -->
            <div id="matchResultDisplay" class="match-result hidden">
                <span class="font-bold">Result:</span> <span id="matchResultMessageText"></span>
            </div>

            <!-- Man of the Match Display -->
            <div id="manOfTheMatchDisplay" class="man-of-the-match hidden">
                Man of the Match: <span id="manOfTheMatchPlayer"></span>
            </div>

            <!-- Final Scorecards Section (initially hidden) -->
            <div id="finalScorecardsSection" class="hidden mt-8 p-4 bg-gray-100 rounded-lg shadow-inner">
                <h2 class="text-2xl font-semibold text-gray-700 mb-6 text-center">Match Summary & Full Scorecards</h2>

                <!-- Team 1 Final Scorecards -->
                <div class="mb-8">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 text-center" id="finalTeam1Name"></h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Batsman Scorecard</h4>
                            <div class="overflow-x-auto">
                                <table id="finalTeam1BatsmanScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Batsman</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Balls</th>
                                            <th class="text-right">SR</th> <!-- Added Strike Rate header -->
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 1 Batsman rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Bowler Scorecard</h4>
                            <div class="overflow-x-auto">
                                <table id="finalTeam1BowlerScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Bowler</th>
                                            <th class="text-right">Overs</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Wickets</th>
                                            <th class="text-right">WD</th>
                                            <th class="text-right">NB</th>
                                            <th class="text-right">Econ</th> <!-- Added Economy header -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 1 Bowler rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <h4 class="text-lg font-semibold text-gray-700 mb-2">Fall of Wickets</h4>
                        <ul id="finalTeam1FOWList" class="fall-of-wickets-list">
                            <!-- Team 1 FOW will be inserted here -->
                        </ul>
                    </div>
                </div>

                <!-- Team 2 Final Scorecards -->
                <div>
                    <h3 class="text-xl font-bold text-gray-800 mb-4 text-center" id="finalTeam2Name"></h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Batsman Scorecard</h4>
                            <div class="overflow-x-auto">
                                <table id="finalTeam2BatsmanScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Batsman</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Balls</th>
                                            <th class="text-right">SR</th> <!-- Added Strike Rate header -->
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 2 Batsman rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Bowler Scorecard</th>
                            <div class="overflow-x-auto">
                                <table id="finalTeam2BowlerScorecard" class="scorecard-table">
                                    <thead>
                                        <tr>
                                            <th>Bowler</th>
                                            <th class="text-right">Overs</th>
                                            <th class="text-right">Runs</th>
                                            <th class="text-right">Wickets</th>
                                            <th class="text-right">WD</th>
                                            <th class="text-right">NB</th>
                                            <th class="text-right">Econ</th> <!-- Added Economy header -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Team 2 Bowler rows will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <h4 class="text-lg font-semibold text-gray-700 mb-2">Fall of Wickets</h4>
                        <ul id="finalTeam2FOWList" class="fall-of-wickets-list">
                            <!-- Team 2 FOW will be inserted here -->
                        </ul>
                    </div>
                </div>
            </div>

            <div class="flex justify-center mt-8 gap-4"> <!-- Changed from text-center to flex justify-center gap-4 -->
                <button id="backBtnMatchSummary">Back to Past Matches</button>
                <button id="restartMatchBtn">Restart Match</button> <!-- NEW -->
                <button id="newMatchBtn">New Match</button>
            </div>
        </div>

        <!-- Past Matches Section -->
        <div id="pastMatchesSection" class="past-matches-section">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">Past Match Summaries</h2>
            <ul id="pastMatchesList" class="past-matches-list">
                <!-- Past matches will be loaded here from localStorage -->
            </ul>
            <div class="flex justify-center mt-4"> <!-- Changed from text-center to flex justify-center -->
                <button id="clearPastMatchesBtn">Clear All Past Matches</button>
            </div>
        </div>

        <!-- Developer Info Section (NEW) -->
        <div id="developerInfoSection" class="hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Developer Information</h2>
            <p>Developed by: SM0786</p>
            <p>Contact: testemail@gmail.com</p>
            <p>&copy; 2025 SM0786. All rights reserved.</p>
            <div class="flex justify-center"> <!-- Added flex justify-center to center the button -->
                <button id="backBtnDeveloperInfo">Back to Main</button>
            </div>
        </div>

        <!-- Developer Info Button (Always present in main app container) -->
        <div class="flex justify-center mt-8">
            <button id="developerInfoBtn">Developer Info</button>
        </div>


        <!-- Message Box for notifications -->
        <div id="messageBox" class="message-box"></div>

        <!-- Custom Confirmation Modal -->
        <div id="confirmationModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-white p-4 rounded-lg shadow-xl text-center max-w-sm w-full"> <!-- Reduced padding and added max-w-sm -->
                <p id="confirmationMessage" class="text-lg font-semibold text-gray-800 mb-4"></p> <!-- Smaller text and margin -->
                <div class="flex justify-center gap-4">
                    <button id="confirmYesBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out">Yes</button>
                    <button id="confirmNoBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out">No</button>
                </div>
            </div>
        </div>

        <!-- NEW: Cancellation Reason Modal -->
        <div id="cancelReasonModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm w-full">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">Cancel Match Reason</h3>
                <div class="mb-4">
                    <label for="cancellationReasonSelect" class="block text-gray-700 text-sm font-bold mb-2">Reason for Cancellation:</label>
                    <select id="cancellationReasonSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                        <option value="">Select a reason</option>
                        <option value="Rain">Rain</option>
                        <option value="Bad Light">Bad Light</option>
                        <option value="Ground Conditions">Ground Conditions</option>
                        <option value="Team Forfeited">Team Forfeited</option>
                        <option value="Other">Other (Specify in notes)</option>
                    </select>
                </div>
                <div class="flex justify-center gap-4">
                    <button id="confirmCancellationReasonBtn" class="bg-red-500 hover:bg-red-600 text-white">Confirm Cancellation</button>
                    <button id="backFromCancelReasonBtn" class="bg-gray-400 hover:bg-gray-500 text-white">Back</button>
                </div>
            </div>
        </div>

        <!-- NEW: Wide Extra Runs Modal -->
        <div id="wideExtraRunsModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm w-full">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">Wide Ball: Extra Runs?</h3>
                <div class="mb-4 flex flex-wrap justify-center gap-4"> <!-- Use flex for radio buttons -->
                    <label class="inline-flex items-center">
                        <input type="radio" name="wideExtraRuns" value="0" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500" checked>
                        <span class="ml-2 text-gray-700">0 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="wideExtraRuns" value="1" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">1 Extra Run</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="wideExtraRuns" value="2" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">2 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="wideExtraRuns" value="3" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">3 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="wideExtraRuns" value="4" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">4 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="wideExtraRuns" value="6" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">6 Extra Runs</span>
                    </label>
                </div>
                <div class="flex justify-center gap-4">
                    <button id="confirmWideExtraRunsBtn" class="bg-green-500 hover:bg-green-600 text-white">Confirm</button>
                    <button id="cancelWideExtraRunsBtn" class="bg-gray-400 hover:bg-gray-500 text-white">Cancel</button>
                </div>
            </div>
        </div>

        <!-- NEW: No Ball Extra Runs Modal (Duplicated and modified from Wide) -->
        <div id="noBallExtraRunsModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm w-full">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">No Ball: Extra Runs?</h3>
                <div class="mb-4 flex flex-wrap justify-center gap-4"> <!-- Use flex for radio buttons -->
                    <label class="inline-flex items-center">
                        <input type="radio" name="noBallExtraRuns" value="0" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500" checked>
                        <span class="ml-2 text-gray-700">0 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="noBallExtraRuns" value="1" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">1 Extra Run</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="noBallExtraRuns" value="2" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">2 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="noBallExtraRuns" value="3" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">3 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="noBallExtraRuns" value="4" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">4 Extra Runs</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="noBallExtraRuns" value="6" class="h-5 w-5 text-blue-600 border-gray-300 rounded-full focus:ring-blue-500">
                        <span class="ml-2 text-gray-700">6 Extra Runs</span>
                    </label>
                </div>
                <div class="flex justify-center gap-4">
                    <button id="confirmNoBallExtraRunsBtn" class="bg-green-500 hover:bg-green-600 text-white">Confirm</button>
                    <button id="cancelNoBallExtraRunsBtn" class="bg-gray-400 hover:bg-gray-500 text-white">Cancel</button>
                </div>
            </div>
        </div>

        <!-- NEW: Fielder Selection Modal -->
        <div id="fielderSelectionModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm w-full">
                <h3 class="text-xl font-semibold text-gray-800 mb-4" id="fielderModalTitle">Select Fielder</h3>
                <div class="mb-4">
                    <label for="fielderSelect" class="block text-gray-700 text-sm font-bold mb-2">Fielder:</label>
                    <select id="fielderSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                        <option value="">Select Fielder</option>
                        <!-- Fielder options populated by JS -->
                    </select>
                </div>
                <div class="flex justify-center gap-4">
                    <button id="confirmFielderBtn" class="bg-green-500 hover:bg-green-600 text-white">Confirm</button>
                    <button id="cancelFielderBtn" class="bg-gray-400 hover:bg-gray-500 text-white">Cancel</button>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // Get references to HTML elements
        const teamRegistrationSection = document.getElementById('teamRegistrationSection');
        const scoreboardSection = document.getElementById('scoreboardSection');
        const teamRegistrationForm = document.getElementById('teamRegistrationForm');
        const registerTeamsBtn = document.getElementById('registerTeamsBtn'); // Get the submit button
        const messageBox = document.getElementById('messageBox');
        const matchReadySection = document.getElementById('matchReadySection'); // New
        const startMatchBtn = document.getElementById('startMatchBtn'); // New
        const registeredTeamsSummary = document.getElementById('registeredTeamsSummary'); // New

        // Toss Section elements (NEW)
        const tossSection = document.getElementById('tossSection');
        const tossWinnerSelect = document.getElementById('tossWinner');
        const tossDecisionSelect = document.getElementById('tossDecision');
        const proceedToMatchReadyBtn = document.getElementById('proceedToMatchReadyBtn');
        const backBtnToss = document.getElementById('backBtnToss'); // NEW Back button for Toss

        // NEW: Captain & Wicket Keeper Selection elements
        const captainWkSelectionSection = document.getElementById('captainWkSelectionSection');
        const team1CaptainSelect = document.getElementById('team1CaptainSelect');
        const team1WkSelect = document.getElementById('team1WkSelect');
        const team2CaptainSelect = document.getElementById('team2CaptainSelect');
        const team2WkSelect = document.getElementById('team2WkSelect');
        const confirmCaptainWkBtn = document.getElementById('confirmCaptainWkBtn');
        const backBtnCaptainWk = document.getElementById('backBtnCaptainWk');
        const displayTeam1NameWk = document.getElementById('displayTeam1NameWk');
        const displayTeam2NameWk = document.getElementById('displayTeam2NameWk');


        // NEW: Playing XI Selection elements
        const playingXISelectionSection = document.getElementById('playingXISelectionSection');
        const team1PlayingXITitle = document.getElementById('team1PlayingXITitle');
        const team2PlayingXITitle = document.getElementById('team2PlayingXITitle');
        const team1PlayersList = document.getElementById('team1PlayersList');
        const team2PlayersList = document.getElementById('team2PlayersList');
        const confirmPlayingXIBtn = document.getElementById('confirmPlayingXIBtn');
        const backBtnPlayingXI = document.getElementById('backBtnPlayingXI'); // Renamed from backToRegistrationFromXI
        const team1PlayingXICounter = document.getElementById('team1PlayingXICounter'); // NEW Counter
        const team2PlayingXICounter = document.getElementById('team2PlayingXICounter'); // NEW Counter
        const resetAllBtn = document.getElementById('resetAllBtn'); // NEW: Reset All button


        // Live Scoreboard elements
        const displayTeam1Name = document.getElementById('displayTeam1Name');
        const team1RunsDisplay = document.getElementById('team1Runs');
        const team1WicketsDisplay = document.getElementById('team1Wickets');
        const team1OversDisplay = document.getElementById('team1Overs');
        const team1ExtrasDisplay = document.getElementById('team1Extras');
        const team1Card = document.getElementById('team1Card');

        const displayTeam2Name = document.getElementById('displayTeam2Name');
        const team2RunsDisplay = document.getElementById('team2Runs');
        const team2WicketsDisplay = document.getElementById('team2Wickets');
        const team2OversDisplay = document.getElementById('team2Overs');
        const team2ExtrasDisplay = document.getElementById('team2Extras');
        const team2Card = document.getElementById('team2Card');

        const currentBattingTeamContainer = document.getElementById('currentBattingTeamContainer'); // NEW ID
        const currentBattingTeamDisplay = document.getElementById('currentBattingTeam');
        const oversRemainingContainer = document.getElementById('oversRemainingContainer'); // NEW ID
        const oversRemainingDisplay = document.getElementById('oversRemaining');
        const tossInfoDisplay = document.getElementById('tossInfoDisplay'); // NEW: Toss Info Display
        const tossWinnerInfo = document.getElementById('tossWinnerInfo'); // NEW: Toss Winner Info
        const tossDecisionInfo = document.getElementById('tossDecisionInfo'); // NEW: Toss Decision Info
        const targetScoreDisplayElement = document.getElementById('targetScoreDisplay');
        const targetScoreElement = document.getElementById('targetScore');
        const freeHitDisplay = document.getElementById('freeHitDisplay'); // New: Free Hit display

        // NEW: Chasing info elements
        const chasingInfoDisplay = document.getElementById('chasingInfoDisplay');
        const runsRequiredDisplay = document.getElementById('runsRequired');
        const ballsRemainingDisplay = document.getElementById('ballsRemaining');
        const wicketsRemainingDisplay = document.getElementById('wicketsRemaining');


        // Player selection dropdowns
        const playerSelection = document.getElementById('playerSelection');
        const strikerSelect = document.getElementById('strikerSelect');
        const nonStrikerSelect = document.getElementById('nonStrikerSelect');
        const bowlerSelect = document.getElementById('bowlerSelect');

        // Score control buttons
        const scoreControls = document.getElementById('scoreControls');
        const add1RunBtn = document.getElementById('add1RunBtn');
        const add2RunsBtn = document.getElementById('add2RunsBtn');
        const add4RunsBtn = document.getElementById('add4RunsBtn');
        const add6RunsBtn = document.getElementById('add6RunsBtn');
        // New Wicket Buttons
        const addCaughtBtn = document.getElementById('addCaughtBtn');
        const addBowledLbwBtn = document.getElementById('addBowledLbwBtn'); // Corrected this line
        const addRunOutBtn = document.getElementById('addRunOutBtn');
        const addStumpedBtn = document.getElementById('addStumpedBtn');
        const addHitWicketBtn = document.getElementById('addHitWicketBtn');
        const addOtherWicketBtn = document.getElementById('addOtherWicketBtn');

        const addBallBtn = document.getElementById('addBallBtn');
        const addWideBtn = document.getElementById('addWideBtn'); // Corrected line
        const addNoBallBtn = document.getElementById('addNoBallBtn');
        const addByeBtn = document.getElementById('addByeBtn');
        const addLegByeBtn = document.getElementById('addLegByeBtn');
        const switchStrikeBtn = document.getElementById('switchStrikeBtn');
        const undoBtn = document.getElementById('undoBtn');
        const switchTeamBtn = document.getElementById('switchTeamBtn');
        const newMatchBtn = document.getElementById('newMatchBtn');
        // const endMatchBtn = document.getElementById('endMatchBtn'); // Removed: End Match button
        const restartMatchBtn = document.getElementById('restartMatchBtn'); // NEW: Restart Match button
        const cancelMatchBtn = document.getElementById('cancelMatchBtn'); // NEW: Cancel Match button

        const matchResultDisplay = document.getElementById('matchResultDisplay');
        const matchResultMessageText = document.getElementById('matchResultMessageText'); // NEW: Span for dynamic message
        const manOfTheMatchDisplay = document.getElementById('manOfTheMatchDisplay');
        const manOfTheMatchPlayer = document.getElementById('manOfTheMatchPlayer');
        const backBtnMatchReady = document.getElementById('backBtnMatchReady'); // NEW Back button for Match Ready
        const backBtnMatchSummary = document.getElementById('backBtnMatchSummary'); // NEW Back button for Match Summary


        // Live Scorecard tables
        const liveBatsmanScorecardTable = document.getElementById('batsmanScorecard').getElementsByTagName('tbody')[0];
        const liveBowlerScorecardTable = document.getElementById('bowlerScorecard').getElementsByTagName('tbody')[0];
        const liveBatsmanScorecardTeamName = document.getElementById('batsmanScorecardTeamName');
        const liveBowlerScorecardTeamName = document.getElementById('bowlerScorecardTeamName');
        const liveFallOfWicketsList = document.getElementById('fallOfWicketsList');
        const liveFowTeamName = document.getElementById('fowTeamName');
        const liveScorecardsSection = document.getElementById('liveScorecards');
        const liveFOWSection = document.getElementById('liveFOW');
        const liveScorePanel = document.querySelector('.live-score-panel'); // NEW: Reference to the live score panel

        // Final Scorecards elements
        const finalScorecardsSection = document.getElementById('finalScorecardsSection');
        const finalTeam1NameDisplay = document.getElementById('finalTeam1Name');
        const finalTeam2NameDisplay = document.getElementById('finalTeam2Name');
        const finalTeam1BatsmanScorecardTable = document.getElementById('finalTeam1BatsmanScorecard').getElementsByTagName('tbody')[0];
        const finalTeam1BowlerScorecardTable = document.getElementById('finalTeam1BowlerScorecard').getElementsByTagName('tbody')[0];
        const finalTeam1FOWList = document.getElementById('finalTeam1FOWList');
        const finalTeam2BatsmanScorecardTable = document.getElementById('finalTeam2BatsmanScorecard').getElementsByTagName('tbody')[0];
        const finalTeam2BowlerScorecardTable = document.getElementById('finalTeam2BowlerScorecard').getElementsByTagName('tbody')[0];
        const finalTeam2FOWList = document.getElementById('finalTeam2FOWList');

        // Past Matches elements
        const pastMatchesSection = document.getElementById('pastMatchesSection');
        const pastMatchesList = document.getElementById('pastMatchesList');
        const clearPastMatchesBtn = document.getElementById('clearPastMatchesBtn');

        // New UI elements for live score page
        const currentOverInfoPanel = document.getElementById('currentOverInfoPanel'); // NEW ID
        const currentOverBallsDisplay = document.getElementById('currentOverBallsDisplay');
        const partnershipInfoPanel = document.getElementById('partnershipInfoPanel'); // NEW ID
        const partnershipRunsDisplay = document.getElementById('partnershipRunsDisplay');

        // Developer Info elements (NEW)
        const developerInfoSection = document.getElementById('developerInfoSection');
        const developerInfoBtn = document.getElementById('developerInfoBtn'); // Now directly referenced

        const backBtnDeveloperInfo = document.getElementById('backBtnDeveloperInfo'); // Renamed from backToMainBtn

        // Custom Confirmation Modal elements
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmationMessage = document.getElementById('confirmationMessage');
        const confirmYesBtn = document.getElementById('confirmYesBtn');
        const confirmNoBtn = document.getElementById('confirmNoBtn');

        // NEW: Cancellation Reason Modal elements
        const cancelReasonModal = document.getElementById('cancelReasonModal');
        const cancellationReasonSelect = document.getElementById('cancellationReasonSelect');
        const confirmCancellationReasonBtn = document.getElementById('confirmCancellationReasonBtn');
        const backFromCancelReasonBtn = document.getElementById('backFromCancelReasonBtn');

        // NEW: Wide Extra Runs Modal elements
        const wideExtraRunsModal = document.getElementById('wideExtraRunsModal');
        // Removed wideExtraRunsInput as it's now radio buttons
        const confirmWideExtraRunsBtn = document.getElementById('confirmWideExtraRunsBtn');
        const cancelWideExtraRunsBtn = document.getElementById('cancelWideExtraRunsBtn');

        // NEW: No Ball Extra Runs Modal (Duplicated and modified from Wide)
        const noBallExtraRunsModal = document.getElementById('noBallExtraRunsModal');
        const confirmNoBallExtraRunsBtn = document.getElementById('confirmNoBallExtraRunsBtn');
        const cancelNoBallExtraRunsBtn = document.getElementById('cancelNoBallExtraRunsBtn');

        // NEW: Fielder Selection Modal elements
        const fielderSelectionModal = document.getElementById('fielderSelectionModal');
        const fielderModalTitle = document.getElementById('fielderModalTitle');
        const fielderSelect = document.getElementById('fielderSelect');
        const confirmFielderBtn = document.getElementById('confirmFielderBtn');
        const cancelFielderBtn = document.getElementById('cancelFielderBtn');


        // Array of all main content sections to easily hide/show them
        const allSections = [
            teamRegistrationSection,
            captainWkSelectionSection, // NEW
            playingXISelectionSection,
            tossSection,
            matchReadySection,
            scoreboardSection,
            pastMatchesSection,
            developerInfoSection
        ];

        // Function to hide all main content sections
        function hideAllSections() {
            allSections.forEach(section => section.classList.add('hidden'));
        }

        // Game state variables
        let team1 = {
            name: '',
            players: [], // Each player will be { name, runsScored, ballsFaced, isOut, wicketsTaken, runsConceded, ballsBowled, wides, noBalls, oversBowled }
            captainName: '', // NEW
            wicketKeeperName: '', // NEW
            playing11Names: [], // NEW: Array of names of players in the playing XI
            runs: 0,
            wickets: 0,
            overs: 0,
            balls: 0,
            totalWides: 0,
            totalNoBalls: 0,
            totalByes: 0,
            totalLegByes: 0,
            currentStrikerIndex: -1, // Index in the `players` array
            currentNonStrikerIndex: -1, // Index in the `players` array
            fallOfWickets: [] // [{ batsman: 'Name', score: 'X/Y', over: 'A.B', dismissalType: 'Caught' }]
        };
        let team2 = {
            name: '',
            players: [],
            captainName: '', // NEW
            wicketKeeperName: '', // NEW
            playing11Names: [], // NEW: Array of names of players in the playing XI
            runs: 0,
            wickets: 0,
            overs: 0,
            balls: 0,
            totalWides: 0,
            totalNoBalls: 0,
            totalByes: 0,
            totalLegByes: 0,
            currentStrikerIndex: -1,
            currentNonStrikerIndex: -1,
            fallOfWickets: []
        };
        let currentBattingTeam = null; // Reference to the currently batting team object
        let currentBowlingTeam = null; // Reference to the currently bowling team object
        let currentBowlerIndex = -1; // Index of the current bowler in the bowling team's `players` array

        let totalOversPerInnings = 0;
        let matchState = 'registration'; // 'registration', 'playing_xi_selection', 'captain_wk_selection', 'toss', 'teams_registered', 'innings1', 'innings2', 'completed', 'cancelled'
        let firstInningsTotalRuns = 0;

        let lastAction = null; // Stores the last action for undo functionality

        let currentPartnershipRuns = 0; // New: Tracks runs scored by the current batting pair
        var isFreeHit = false; // New: Free hit state
        var lastCompletedBowlerIndex = -1; // New: Stores the index of the bowler who just completed an over

        let tossWinnerName = ''; // NEW: Stores the name of the team that won the toss
        let tossDecision = ''; // NEW: Stores the toss decision ('bat' or 'bowl')
        let cancellationReason = ''; // NEW: Stores the reason for match cancellation


        // Function to show a message box
        function showMessageBox(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = `message-box show ${type}`; // Add show and type class
            setTimeout(() => {
                messageBox.classList.remove('show'); // Hide after 3 seconds
            }, 3000);
        }

        // Function to show a custom confirmation modal
        function showConfirmationModal(message, onConfirm, onCancel) {
            confirmationMessage.textContent = message;
            confirmationModal.classList.remove('hidden');

            // Remove existing listeners to prevent multiple calls
            confirmYesBtn.removeEventListener('click', confirmYesBtn.currentListener);
            confirmNoBtn.removeEventListener('click', confirmNoBtn.currentListener);

            const handleConfirm = () => {
                confirmationModal.classList.add('hidden');
                onConfirm();
            };

            const handleCancel = () => {
                confirmationModal.classList.add('hidden');
                if (onCancel) onCancel(); // Only call onCancel if provided
            };

            // Store and add new listeners
            confirmYesBtn.currentListener = handleConfirm;
            confirmNoBtn.currentListener = handleCancel;
            confirmYesBtn.addEventListener('click', confirmYesBtn.currentListener);
            confirmNoBtn.addEventListener('click', confirmNoBtn.currentListener);
        }

        // Helper function to get players in the playing XI
        function getPlayingXIPlayers(team) {
            return team.players.filter(player => team.playing11Names.includes(player.name));
        }

        // Function to update the UI based on the current matchState
        function updateUIForMatchState() {
            hideAllSections(); // Hide all sections first

            // Hide developer info button by default, then show it if not on developer info page
            developerInfoBtn.classList.add('hidden');
            backBtnDeveloperInfo.classList.add('hidden'); // Also hide the back button

            // Hide all score-related info panels and controls by default for non-scoreboard states
            currentBattingTeamContainer.classList.add('hidden');
            oversRemainingContainer.classList.add('hidden');
            tossInfoDisplay.classList.add('hidden');
            targetScoreDisplayElement.classList.add('hidden');
            chasingInfoDisplay.classList.add('hidden');
            freeHitDisplay.classList.add('hidden');
            currentOverInfoPanel.classList.add('hidden');
            partnershipInfoPanel.classList.add('hidden');
            playerSelection.classList.add('hidden');
            scoreControls.classList.add('hidden');
            liveScorePanel.classList.add('hidden');
            liveScorecardsSection.classList.add('hidden');
            liveFOWSection.classList.add('hidden');
            matchResultDisplay.classList.add('hidden');
            manOfTheMatchDisplay.classList.add('hidden');
            finalScorecardsSection.classList.add('hidden');
            restartMatchBtn.classList.add('hidden');
            cancelMatchBtn.classList.add('hidden');
            newMatchBtn.classList.add('hidden');
            backBtnMatchSummary.classList.add('hidden');


            switch (matchState) {
                case 'registration':
                    teamRegistrationSection.classList.remove('hidden');
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button
                    newMatchBtn.classList.remove('hidden'); // Show New Match button
                    break;
                case 'playing_xi_selection':
                    playingXISelectionSection.classList.remove('hidden');
                    renderPlayingXISelection(); // Render checkboxes for playing XI
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button
                    newMatchBtn.classList.remove('hidden'); // Show New Match button
                    break;
                case 'captain_wk_selection':
                    captainWkSelectionSection.classList.remove('hidden');
                    renderCaptainWkSelection(); // Render dropdowns for Captain/WK
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button
                    newMatchBtn.classList.remove('hidden'); // Show New Match button
                    break;
                case 'toss':
                    tossSection.classList.remove('hidden');
                    populateTossDropdowns(); // Populate toss dropdowns
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button
                    newMatchBtn.classList.remove('hidden'); // Show New Match button
                    break;
                case 'teams_registered':
                    matchReadySection.classList.remove('hidden');
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button
                    newMatchBtn.classList.remove('hidden'); // Show New Match button
                    break;
                case 'innings1':
                case 'innings2':
                    scoreboardSection.classList.remove('hidden');
                    currentBattingTeamContainer.classList.remove('hidden');
                    oversRemainingContainer.classList.remove('hidden');
                    tossInfoDisplay.classList.remove('hidden');
                    currentOverInfoPanel.classList.remove('hidden');
                    partnershipInfoPanel.classList.remove('hidden');
                    playerSelection.classList.remove('hidden');
                    scoreControls.classList.remove('hidden');
                    liveScorePanel.classList.remove('hidden');
                    liveScorecardsSection.classList.remove('hidden');
                    liveFOWSection.classList.remove('hidden');
                    restartMatchBtn.classList.remove('hidden'); // Show restart button during active play
                    cancelMatchBtn.classList.remove('hidden'); // Show cancel button during active play
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button
                    updateScoreboardDisplay(); // Ensure scoreboard is updated
                    break;
                case 'completed':
                case 'cancelled':
                    scoreboardSection.classList.remove('hidden');
                    matchResultDisplay.classList.remove('hidden');
                    manOfTheMatchDisplay.classList.remove('hidden');
                    finalScorecardsSection.classList.remove('hidden');
                    renderFinalScorecards(); // Render final scorecards
                    restartMatchBtn.classList.remove('hidden'); // Show restart button
                    newMatchBtn.classList.remove('hidden'); // Show new match button
                    backBtnMatchSummary.classList.remove('hidden'); // Show back to summary button
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button

                    // Disable score controls and player selectors when match is completed/cancelled
                    Array.from(scoreControls.children).forEach(button => button.disabled = true);
                    strikerSelect.disabled = true;
                    nonStrikerSelect.disabled = true;
                    bowlerSelect.disabled = true;
                    break;
                case 'past_matches':
                    pastMatchesSection.classList.remove('hidden');
                    loadPastMatchesLocal(); // Ensure past matches are loaded
                    developerInfoBtn.classList.remove('hidden'); // Show developer info button
                    newMatchBtn.classList.remove('hidden'); // Show New Match button
                    break;
                case 'developer_info':
                    developerInfoSection.classList.remove('hidden');
                    developerInfoBtn.classList.add('hidden'); // Hide developer info button when on its page
                    backBtnDeveloperInfo.classList.remove('hidden'); // Show back button on developer info page
                    break;
                default:
                    teamRegistrationSection.classList.remove('hidden'); // Default to registration
                    developerInfoBtn.classList.remove('hidden');
                    newMatchBtn.classList.remove('hidden'); // Show New Match button
                    break;
            }
        }


        // Function to populate player dropdowns (now uses playing11Names)
        function populatePlayerDropdowns() {
            strikerSelect.innerHTML = '<option value="">Select Striker</option>';
            nonStrikerSelect.innerHTML = '<option value="">Select Non-Striker</option>';
            bowlerSelect.innerHTML = '<option value="">Select Bowler</option>';

            if (currentBattingTeam && currentBowlingTeam) {
                const battingXI = getPlayingXIPlayers(currentBattingTeam);
                const bowlingXI = getPlayingXIPlayers(currentBowlingTeam);

                // Populate batsmen for the batting team's Playing XI
                battingXI.forEach((player) => {
                    // Find the original index of the player in the full players array
                    const originalIndex = currentBattingTeam.players.findIndex(p => p.name === player.name);
                    
                    const optionStriker = document.createElement('option');
                    optionStriker.value = originalIndex; // Use original index
                    optionStriker.textContent = player.name;
                    if (player.isOut) { // If player is out, disable and add (Out) text
                        optionStriker.disabled = true;
                        optionStriker.textContent += ' (Out)';
                    }
                    strikerSelect.appendChild(optionStriker);

                    const optionNonStriker = document.createElement('option');
                    optionNonStriker.value = originalIndex; // Use original index
                    optionNonStriker.textContent = player.name;
                    if (player.isOut) { // If player is out, disable and add (Out) text
                        optionNonStriker.disabled = true;
                        optionNonStriker.textContent += ' (Out)';
                    }
                    nonStrikerSelect.appendChild(optionNonStriker);
                });

                // Populate bowlers for the bowling team's Playing XI
                bowlingXI.forEach((player) => {
                    // Find the original index of the player in the full players array
                    const originalIndex = currentBowlingTeam.players.findIndex(p => p.name === player.name);
                    const optionBowler = document.createElement('option');
                    optionBowler.value = originalIndex; // Use original index
                    optionBowler.textContent = player.name;
                    // Disable the last bowler if it's a new over (currentBattingTeam.balls === 0)
                    // and the bowler's original index matches the lastCompletedBowlerIndex
                    if (originalIndex === lastCompletedBowlerIndex && currentBattingTeam.balls === 0) {
                        optionBowler.disabled = true;
                        optionBowler.textContent += ' (Last Over)'; // Add a visual cue
                    }
                    bowlerSelect.appendChild(optionBowler);
                });

                // Set selected values if batsmen/bowler are already chosen
                strikerSelect.value = currentBattingTeam.currentStrikerIndex !== -1 ? currentBattingTeam.currentStrikerIndex : '';
                nonStrikerSelect.value = currentBattingTeam.currentNonStrikerIndex !== -1 ? currentBattingTeam.currentNonStrikerIndex : '';
                bowlerSelect.value = currentBowlerIndex !== -1 ? currentBowlerIndex : '';
            }
        }

        // Event listeners for player selection changes
        strikerSelect.addEventListener('change', (event) => {
            const newStrikerIndex = parseInt(event.target.value);
            // Ensure the selected index is valid and corresponds to a player in the playing XI
            if (newStrikerIndex !== -1 && !currentBattingTeam.playing11Names.includes(currentBattingTeam.players[newStrikerIndex].name)) {
                showMessageBox('Selected player is not in the Playing XI.', 'error');
                strikerSelect.value = currentBattingTeam.currentStrikerIndex !== -1 ? currentBattingTeam.currentStrikerIndex : '';
                return;
            }
            if (newStrikerIndex === currentBattingTeam.currentNonStrikerIndex) {
                showMessageBox('Striker and Non-Striker cannot be the same player.', 'error');
                strikerSelect.value = currentBattingTeam.currentStrikerIndex !== -1 ? currentBattingTeam.currentStrikerIndex : '';
                return;
            }
            currentBattingTeam.currentStrikerIndex = newStrikerIndex;
            showMessageBox(`${currentBattingTeam.players[newStrikerIndex].name} is now the Striker.`, 'success');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        });

        nonStrikerSelect.addEventListener('change', (event) => {
            const newNonStrikerIndex = parseInt(event.target.value);
            // Ensure the selected index is valid and corresponds to a player in the playing XI
            if (newNonStrikerIndex !== -1 && !currentBattingTeam.playing11Names.includes(currentBattingTeam.players[newNonStrikerIndex].name)) {
                showMessageBox('Selected player is not in the Playing XI.', 'error');
                nonStrikerSelect.value = currentBattingTeam.currentNonStrikerIndex !== -1 ? currentBattingTeam.currentNonStrikerIndex : '';
                return;
            }
            if (newNonStrikerIndex === currentBattingTeam.currentStrikerIndex) {
                showMessageBox('Striker and Non-Striker cannot be the same player.', 'error');
                nonStrikerSelect.value = currentBattingTeam.currentNonStrikerIndex !== -1 ? currentBattingTeam.currentNonStrikerIndex : '';
                return;
            }
            currentBattingTeam.currentNonStrikerIndex = newNonStrikerIndex;
            showMessageBox(`${currentBattingTeam.players[newNonStrikerIndex].name} is now the Non-Striker.`, 'success');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        });

        bowlerSelect.addEventListener('change', (event) => {
            const newBowlerIndex = parseInt(event.target.value);
            // Ensure the selected index is valid and corresponds to a player in the playing XI
            if (newBowlerIndex !== -1 && !currentBowlingTeam.playing11Names.includes(currentBowlingTeam.players[newBowlerIndex].name)) {
                showMessageBox('Selected player is not in the Playing XI.', 'error');
                bowlerSelect.value = currentBowlerIndex !== -1 ? currentBowlerIndex : '';
                return;
            }

            // Check if it's the start of a new over AND the selected bowler is the one who just bowled
            if (currentBattingTeam.balls === 0 && newBowlerIndex === lastCompletedBowlerIndex) {
                showMessageBox('This bowler cannot bowl the next over. Please select a different bowler.', 'error');
                bowlerSelect.value = ''; // Reset dropdown to empty
                currentBowlerIndex = -1; // Ensure no bowler is selected
                return; // Stop further execution
            }

            // If a valid bowler is selected (either not the previous bowler, or it's not the start of a new over)
            currentBowlerIndex = newBowlerIndex;
            showMessageBox(`${currentBowlingTeam.players[currentBowlerIndex].name} is now bowling.`, 'success');

            // Note: lastCompletedBowlerIndex is now only cleared when the first ball of the *new* over is bowled.
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal();
        });

        // Function to update the scoreboard display and scorecards
        function updateScoreboardDisplay() {
            // Update Team 1 display
            displayTeam1Name.textContent = team1.name;
            team1RunsDisplay.textContent = team1.runs;
            team1WicketsDisplay.textContent = team1.wickets;
            team1OversDisplay.textContent = `${team1.overs}.${team1.balls}`;
            team1ExtrasDisplay.textContent = team1.totalWides + team1.totalNoBalls + team1.totalByes + team1.totalLegByes;

            // Update Team 2 display
            displayTeam2Name.textContent = team2.name;
            team2RunsDisplay.textContent = team2.runs;
            team2WicketsDisplay.textContent = team2.wickets;
            team2OversDisplay.textContent = `${team2.overs}.${team2.balls}`;
            team2ExtrasDisplay.textContent = team2.totalWides + team2.totalNoBalls + team2.totalByes + team2.totalLegByes;

            // Highlight the current batting team
            team1Card.classList.remove('active');
            team2Card.classList.remove('active');
            if (currentBattingTeam === team1) {
                team1Card.classList.add('active');
                currentBattingTeamDisplay.textContent = team1.name;
            } else if (currentBattingTeam === team2) {
                team2Card.classList.add('active');
                currentBattingTeamDisplay.textContent = team2.name;
            } else {
                currentBattingTeamDisplay.textContent = 'N/A'; // No team batting yet
            }

            // Update overs remaining
            if (matchState === 'innings1' || matchState === 'innings2') {
                const ballsBowledInCurrentOver = currentBattingTeam.balls;
                const fullOversBowled = currentBattingTeam.overs;
                const totalBallsBowled = (fullOversBowled * 6) + ballsBowledInCurrentOver;
                const totalBallsInMatch = totalOversPerInnings * 6;
                const ballsRemainingOverall = totalBallsInMatch - totalBallsBowled;

                if (ballsRemainingOverall >= 0) {
                    const remainingOvers = Math.floor(ballsRemainingOverall / 6);
                    const remainingBalls = ballsRemainingOverall % 6;
                    oversRemainingDisplay.textContent = `${remainingOvers}.${remainingBalls}`;
                } else {
                    oversRemainingDisplay.textContent = '0.0'; // Should not happen if logic is correct
                }
            } else {
                oversRemainingDisplay.textContent = 'N/A';
            }

            // Show/hide target score and chasing info
            if (matchState === 'innings2') {
                targetScoreDisplayElement.classList.remove('hidden');
                targetScoreElement.textContent = firstInningsTotalRuns + 1;

                const runsNeeded = (firstInningsTotalRuns + 1) - currentBattingTeam.runs;
                const ballsLeft = (totalOversPerInnings * 6) - (currentBattingTeam.overs * 6 + currentBattingTeam.balls);
                const wicketsLeft = (getPlayingXIPlayers(currentBattingTeam).length - 1) - currentBattingTeam.wickets; // Use playing XI length

                runsRequiredDisplay.textContent = Math.max(0, runsNeeded); // Ensure non-negative
                ballsRemainingDisplay.textContent = Math.max(0, ballsLeft); // Ensure non-negative
                wicketsRemainingDisplay.textContent = Math.max(0, wicketsLeft); // Ensure non-negative

                chasingInfoDisplay.classList.remove('hidden');

            } else {
                targetScoreDisplayElement.classList.add('hidden');
                chasingInfoDisplay.classList.add('hidden'); // Hide chasing info if not innings 2
            }

            // Update new UI elements
            currentOverBallsDisplay.textContent = currentBattingTeam ? currentBattingTeam.balls : 0;
            partnershipRunsDisplay.textContent = currentPartnershipRuns;

            // Update Free Hit display
            if (isFreeHit) {
                freeHitDisplay.classList.remove('hidden');
            } else {
                freeHitDisplay.classList.add('hidden');
            }

            // Only render live scorecards if match is active and playing XI is selected
            if ((matchState === 'innings1' || matchState === 'innings2') && currentBattingTeam.playing11Names.length === 11) {
                renderBatsmanScorecard(currentBattingTeam, liveBatsmanScorecardTable, liveBatsmanScorecardTeamName, true); // Pass true for live
                renderBowlerScorecard(currentBowlingTeam, liveBowlerScorecardTable, liveBowlerScorecardTeamName, true); // Pass true for live
                renderFallOfWickets(currentBattingTeam, liveFallOfWicketsList, liveFowTeamName);
                populatePlayerDropdowns(); // Re-populate dropdowns to update selected players
            }
        }

        // Function to add runs
        function addRuns(runs) {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBattingTeam.currentStrikerIndex === -1 || currentBowlerIndex === -1) {
                showMessageBox('Please select striker and bowler.', 'error');
                return;
            }

            const striker = currentBattingTeam.players[currentBattingTeam.currentStrikerIndex];
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            striker.runsScored += runs;
            striker.ballsFaced++;
            currentBattingTeam.runs += runs;
            bowler.runsConceded += runs;
            currentBattingTeam.balls++; // A run implies a ball bowled
            bowler.ballsBowled++;

            // Store previous partnership runs for undo
            lastAction = {
                type: 'run',
                runs: runs,
                strikerIndex: currentBattingTeam.currentStrikerIndex,
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                wasStrikeSwitched: false, // Will be updated if strike is switched
                prevPartnershipRuns: currentPartnershipRuns, // Store partnership before this action
                prevIsFreeHit: isFreeHit
            };
            currentPartnershipRuns += runs; // Update partnership

            // Apply flash effect to runs display
            const runsDisplayElement = currentBattingTeam === team1 ? team1RunsDisplay : team2RunsDisplay;
            runsDisplayElement.classList.add('flash-effect');
            setTimeout(() => runsDisplayElement.classList.remove('flash-effect'), 300);


            // If runs are odd, switch strike
            if (runs % 2 !== 0) {
                switchStrike(true); // true means it's an automatic switch
                lastAction.wasStrikeSwitched = true;
            }

            isFreeHit = false; // Free hit ends after a legal delivery
            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to add a wicket (now handles fielder selection)
        function addWicket(dismissalType) {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBattingTeam.currentStrikerIndex === -1 || currentBowlerIndex === -1) {
                showMessageBox('Please select striker and bowler.', 'error');
                return;
            }

            const striker = currentBattingTeam.players[currentBattingTeam.currentStrikerIndex];
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // Determine the maximum wickets allowed for this team (all players in playing XI except one)
            const maxWickets = getPlayingXIPlayers(currentBattingTeam).length - 1;

            if (currentBattingTeam.wickets >= maxWickets) {
                showMessageBox(`${currentBattingTeam.name} is already all out!`, 'error');
                return;
            }

            // Handle Free Hit first
            if (isFreeHit && dismissalType !== 'Run Out') { // Run Out is the only dismissal on a free hit
                showMessageBox(`Wicket on Free Hit! ${striker.name} is not out (${dismissalType}), but ball counted.`, 'info');
                striker.ballsFaced++; // Still counts as a ball faced
                bowler.ballsBowled++; // Still counts as a ball bowled
                currentBattingTeam.balls++; // Still counts as a ball in the over
                // No wicket is recorded, no change to runs
                lastAction = {
                    type: 'freeHitWicketAttempt',
                    strikerIndex: currentBattingTeam.currentStrikerIndex,
                    bowlerIndex: currentBowlerIndex,
                    team: currentBattingTeam === team1 ? 'team1' : 'team2',
                    prevPartnershipRuns: currentPartnershipRuns,
                    prevIsFreeHit: isFreeHit,
                    dismissalType: dismissalType // Store for undo message
                };
                isFreeHit = false; // Free hit ends
                checkInningsCompletion();
                updateScoreboardDisplay();
                saveCurrentMatchStateToLocal();
                return;
            }

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            // For Caught and Run Out, show fielder selection modal
            if (dismissalType === 'Caught' || dismissalType === 'Run Out') {
                fielderModalTitle.textContent = `Select Fielder for ${dismissalType}`;
                fielderSelect.innerHTML = '<option value="">Select Fielder</option>';

                // Populate fielder dropdown with players from the bowling team's playing XI
                getPlayingXIPlayers(currentBowlingTeam).forEach((player, index) => {
                    const option = document.createElement('option');
                    option.value = player.name;
                    option.textContent = player.name;
                    fielderSelect.appendChild(option);
                });

                fielderSelectionModal.classList.remove('hidden');

                // Store current context for modal callbacks
                fielderSelectionModal.currentDismissalType = dismissalType;
                fielderSelectionModal.currentStriker = striker;
                fielderSelectionModal.currentBowler = bowler;

                // Remove previous listeners to prevent duplicates
                confirmFielderBtn.removeEventListener('click', fielderSelectionModal.confirmListener);
                cancelFielderBtn.removeEventListener('click', fielderSelectionModal.cancelListener);

                // Add new listeners
                fielderSelectionModal.confirmListener = () => {
                    const selectedFielderName = fielderSelect.value;
                    if (!selectedFielderName) {
                        showMessageBox('Please select a fielder.', 'error');
                        return;
                    }
                    processWicket(fielderSelectionModal.currentStriker, fielderSelectionModal.currentBowler, fielderSelectionModal.currentDismissalType, selectedFielderName);
                    fielderSelectionModal.classList.add('hidden');
                };
                fielderSelectionModal.cancelListener = () => {
                    fielderSelectionModal.classList.add('hidden');
                    showMessageBox('Wicket action cancelled.', 'info');
                };

                confirmFielderBtn.addEventListener('click', fielderSelectionModal.confirmListener);
                cancelFielderBtn.addEventListener('click', fielderSelectionModal.cancelListener);

            } else {
                // For other dismissal types (Bowled/LBW, Stumped, Hit Wicket, Other), proceed directly
                processWicket(striker, bowler, dismissalType);
            }
        }

        // Helper function to process the wicket after fielder selection (if applicable)
        function processWicket(striker, bowler, dismissalType, fielderName = null) {
            striker.isOut = true;
            currentBattingTeam.wickets++;
            if (dismissalType !== 'Run Out' && dismissalType !== 'Hit Wicket') { // Bowler gets credit for most wickets
                bowler.wicketsTaken++;
            }
            striker.ballsFaced++; // A wicket implies a ball bowled
            bowler.ballsBowled++;
            currentBattingTeam.balls++;

            // Record fall of wicket
            currentBattingTeam.fallOfWickets.push({
                batsman: striker.name,
                score: `${currentBattingTeam.runs}/${currentBattingTeam.wickets}`,
                over: `${currentBattingTeam.overs}.${currentBattingTeam.balls}`,
                dismissalType: dismissalType,
                fielder: fielderName // Store fielder's name
            });

            // Store previous partnership runs for undo
            lastAction = {
                type: 'wicket',
                batsmanOutIndex: currentBattingTeam.currentStrikerIndex,
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                previousStrikerIndex: currentBattingTeam.currentStrikerIndex,
                previousNonStrikerIndex: currentBattingTeam.currentNonStrikerIndex,
                prevPartnershipRuns: currentPartnershipRuns, // Store partnership before this action
                prevIsFreeHit: isFreeHit,
                dismissalType: dismissalType, // Store dismissal type for undo
                fielderName: fielderName
            };
            currentPartnershipRuns = 0; // Reset partnership on wicket

            // Apply flash effect to wickets display
            const wicketsDisplayElement = currentBattingTeam === team1 ? team1WicketsDisplay : team2WicketsDisplay;
            wicketsDisplayElement.classList.add('flash-effect');
            setTimeout(() => wicketsDisplayElement.classList.remove('flash-effect'), 300);

            // Select next batsman from playing XI
            let nextBatsmanIndex = -1;
            const battingXIPlayers = getPlayingXIPlayers(currentBattingTeam);
            for (let i = 0; i < battingXIPlayers.length; i++) {
                const player = battingXIPlayers[i];
                const originalPlayerIndex = currentBattingTeam.players.findIndex(p => p.name === player.name);
                if (!player.isOut && originalPlayerIndex !== currentBattingTeam.currentNonStrikerIndex) {
                    nextBatsmanIndex = originalPlayerIndex;
                    break;
                }
            }

            if (nextBatsmanIndex !== -1) {
                currentBattingTeam.currentStrikerIndex = nextBatsmanIndex;
                let message = `${striker.name} is out by ${dismissalType}!`;
                if (fielderName) {
                    message += ` (Fielder: ${fielderName})`;
                }
                message += ` ${currentBattingTeam.players[nextBatsmanIndex].name} is new striker.`;
                showMessageBox(message, 'success');
            } else {
                // All out scenario (no more available batsmen in playing XI)
                currentBattingTeam.currentStrikerIndex = -1;
                currentBattingTeam.currentNonStrikerIndex = -1;
                let message = `${striker.name} is out by ${dismissalType}!`;
                if (fielderName) {
                    message += ` (Fielder: ${fielderName})`;
                }
                message += ` ${currentBattingTeam.name} All Out!`;
                showMessageBox(message, 'success');
            }
            isFreeHit = false; // Free hit ends after a legal delivery (even if it's a wicket)

            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }


        // Function to add a dot ball
        function addBall() {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBattingTeam.currentStrikerIndex === -1 || currentBowlerIndex === -1) {
                showMessageBox('Please select striker and bowler.', 'error');
                return;
            }

            const striker = currentBattingTeam.players[currentBattingTeam.currentStrikerIndex];
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            striker.ballsFaced++;
            bowler.ballsBowled++;
            currentBattingTeam.balls++;

            // Store previous partnership runs for undo (no change to partnership for dot ball)
            lastAction = {
                type: 'ball',
                strikerIndex: currentBattingTeam.currentStrikerIndex,
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            isFreeHit = false; // Free hit ends after a legal delivery

            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Functions for Extras
        function addWide() {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }

            // Ensure '0 Extra Runs' is selected by default when modal opens
            document.querySelector('input[name="wideExtraRuns"][value="0"]').checked = true;
            wideExtraRunsModal.classList.remove('hidden');

            // Set up event listeners for modal buttons
            confirmWideExtraRunsBtn.onclick = () => {
                const selectedRadio = document.querySelector('input[name="wideExtraRuns"]:checked');
                const extraRuns = selectedRadio ? parseInt(selectedRadio.value) : 0; // Default to 0 if no selection for some reason
                processWide(extraRuns);
                wideExtraRunsModal.classList.add('hidden');
            };
            cancelWideExtraRunsBtn.onclick = () => {
                wideExtraRunsModal.classList.add('hidden');
                showMessageBox('Wide ball action cancelled.', 'info');
            };
        }

        // Helper function to process the wide after getting extra runs
        function processWide(extraRuns) {
            const bowler = currentBowlingTeam.players[currentBowlerIndex];
            const totalRunsAdded = 1 + extraRuns; // 1 for the wide itself, plus any extra runs

            currentBattingTeam.runs += totalRunsAdded;
            currentBattingTeam.totalWides += 1; // Only count one wide event
            bowler.runsConceded += totalRunsAdded;
            bowler.wides += 1; // Only count one wide for the bowler

            lastAction = {
                type: 'wide',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit,
                totalRunsAdded: totalRunsAdded, // Store total runs added for undo
                extraRuns: extraRuns // Store extra runs for undo message
            };

            // Apply flash effect to runs display
            const runsDisplayElement = currentBattingTeam === team1 ? team1RunsDisplay : team2RunsDisplay;
            runsDisplayElement.classList.add('flash-effect');
            setTimeout(() => runsDisplayElement.classList.remove('flash-effect'), 300);

            // Wide does not end a free hit, as it's not a legal delivery
            checkInningsCompletion(); // Wide doesn't count as a ball, but check innings completion
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
            showMessageBox(`Wide ball recorded. ${totalRunsAdded} runs added.`, 'success');
        }


        function addNoBall() {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }

            // Ensure '0 Extra Runs' is selected by default when modal opens
            document.querySelector('input[name="noBallExtraRuns"][value="0"]').checked = true;
            noBallExtraRunsModal.classList.remove('hidden');

            // Set up event listeners for modal buttons
            confirmNoBallExtraRunsBtn.onclick = () => {
                const selectedRadio = document.querySelector('input[name="noBallExtraRuns"]:checked');
                const extraRuns = selectedRadio ? parseInt(selectedRadio.value) : 0; // Default to 0 if no selection for some reason
                processNoBall(extraRuns);
                noBallExtraRunsModal.classList.add('hidden');
            };
            cancelNoBallExtraRunsBtn.onclick = () => {
                noBallExtraRunsModal.classList.add('hidden');
                showMessageBox('No Ball action cancelled.', 'info');
            };
        }

        // Helper function to process the no ball after getting extra runs
        function processNoBall(extraRuns) {
            const bowler = currentBowlingTeam.players[currentBowlerIndex];
            const totalRunsAdded = 1 + extraRuns; // 1 for the no ball itself, plus any extra runs

            currentBattingTeam.runs += totalRunsAdded;
            currentBattingTeam.totalNoBalls += 1; // Only count one no ball event
            bowler.runsConceded += totalRunsAdded;
            bowler.noBalls += 1; // Only count one no ball for the bowler

            lastAction = {
                type: 'noBall',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit,
                totalRunsAdded: totalRunsAdded, // Store total runs added for undo
                extraRuns: extraRuns // Store extra runs for undo message
            };
            isFreeHit = true; // Set free hit for the next ball
            showMessageBox(`No Ball recorded. ${totalRunsAdded} runs added. Free Hit on next delivery!`, 'info');

            // Apply flash effect to runs display
            const runsDisplayElement = currentBattingTeam === team1 ? team1RunsDisplay : team2RunsDisplay;
            runsDisplayElement.classList.add('flash-effect');
            setTimeout(() => runsDisplayElement.classList.remove('flash-effect'), 300);

            checkInningsCompletion(); // No ball doesn't count as a ball, but check innings completion
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }


        function addBye() {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            currentBattingTeam.runs += 1; // 1 run for bye
            currentBattingTeam.totalByes += 1;
            currentBattingTeam.balls++; // Bye counts as a ball
            bowler.ballsBowled++; // Bowler bowls a ball

            // Store previous partnership runs for undo (partnership does not increase for extras not off bat)
            lastAction = {
                type: 'bye',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            isFreeHit = false; // Free hit ends after a legal delivery (even if it's a bye)

            // Apply flash effect to runs display
            const runsDisplayElement = currentBattingTeam === team1 ? team1RunsDisplay : team2RunsDisplay;
            runsDisplayElement.classList.add('flash-effect');
            setTimeout(() => runsDisplayElement.classList.remove('flash-effect'), 300);

            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        function addLegBye() {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }
            if (!currentBattingTeam || currentBowlerIndex === -1) {
                showMessageBox('Please select bowler.', 'error');
                return;
            }
            const bowler = currentBowlingTeam.players[currentBowlerIndex];

            // If it's the first ball of a new over, clear the lastCompletedBowlerIndex restriction
            if (currentBattingTeam.balls === 0 && lastCompletedBowlerIndex !== -1) {
                lastCompletedBowlerIndex = -1;
            }

            currentBattingTeam.runs += 1; // 1 run for leg bye
            currentBattingTeam.totalLegByes += 1;
            currentBattingTeam.balls++; // Leg bye counts as a ball
            bowler.ballsBowled++; // Bowler bowls a ball

            // Store previous partnership runs for undo (partnership does not increase for extras not off bat)
            lastAction = {
                type: 'legBye',
                bowlerIndex: currentBowlerIndex,
                team: currentBattingTeam === team1 ? 'team1' : 'team2',
                prevPartnershipRuns: currentPartnershipRuns,
                prevIsFreeHit: isFreeHit
            };
            isFreeHit = false; // Free hit ends after a legal delivery (even if it's a leg bye)

            // Apply flash effect to runs display
            const runsDisplayElement = currentBattingTeam === team1 ? team1RunsDisplay : team2RunsDisplay;
            runsDisplayElement.classList.add('flash-effect');
            setTimeout(() => runsDisplayElement.classList.remove('flash-effect'), 300);

            checkInningsCompletion();
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to switch strike between the two current batsmen
        function switchStrike(isAutomatic = false) {
            if (currentBattingTeam.currentStrikerIndex !== -1 && currentBattingTeam.currentNonStrikerIndex !== -1) {
                const temp = currentBattingTeam.currentStrikerIndex;
                currentBattingTeam.currentStrikerIndex = currentBattingTeam.currentNonStrikerIndex;
                currentBattingTeam.currentNonStrikerIndex = temp;
                populatePlayerDropdowns(); // Update dropdowns to reflect strike change
                if (!isAutomatic) {
                    showMessageBox('Strike switched manually.', 'info');
                    saveCurrentMatchStateToLocal(); // Save changes to local storage
                }
            } else if (!isAutomatic) {
                showMessageBox('Cannot switch strike: ensure both batsmen are selected.', 'error');
            }
        }

        // Helper function to check for over completion and innings completion
        function checkInningsCompletion() {
            // Update full overs for the team
            if (currentBattingTeam.balls >= 6) {
                currentBattingTeam.overs += Math.floor(currentBattingTeam.balls / 6);
                currentBattingTeam.balls = currentBattingTeam.balls % 6;
                // After an over, automatically switch strike
                switchStrike(true); // Automatic switch
                lastCompletedBowlerIndex = currentBowlerIndex; // Store the bowler who just completed the over
                currentBowlerIndex = -1; // Reset current bowler
                bowlerSelect.value = ''; // Clear dropdown
                showMessageBox('Over completed! Select a new bowler.', 'info');
            }

            // Update full overs for the current bowler
            if (currentBowlerIndex !== -1) {
                const bowler = currentBowlingTeam.players[currentBowlerIndex];
                if (bowler.ballsBowled >= 6) {
                    bowler.oversBowled += Math.floor(bowler.ballsBowled / 6);
                    bowler.ballsBowled = bowler.ballsBowled % 6;
                }
            }

            // Determine the "all out" condition dynamically using playing XI
            const isAllOut = currentBattingTeam.wickets === (getPlayingXIPlayers(currentBattingTeam).length - 1);
            const allOversBowled = currentBattingTeam.overs >= totalOversPerInnings;

            if (matchState === 'innings1') {
                if (isAllOut || allOversBowled) {
                    // Corrected: Set firstInningsTotalRuns to the runs of the team that just batted (currentBattingTeam)
                    firstInningsTotalRuns = currentBattingTeam.runs;
                    showMessageBox(`${currentBattingTeam.name} Innings Completed! Target for ${currentBowlingTeam.name} is ${firstInningsTotalRuns + 1}.`, 'success');
                    matchState = 'innings2';
                    switchBattingTeam(); // Automatically switch to the other team for chasing
                    updateScoreboardDisplay(); // Update display immediately after switch
                    saveCurrentMatchStateToLocal(); // Save changes to local storage
                }
            } else if (matchState === 'innings2') {
                // Check for win condition immediately when target is surpassed
                if (currentBattingTeam.runs > firstInningsTotalRuns) {
                    declareWinner('Completed'); // Pass status 'Completed'
                    return; // Exit to prevent further score updates
                }

                if (isAllOut || allOversBowled) {
                    declareWinner('Completed'); // Pass status 'Completed'
                }
            }
        }

        // Function to switch the batting team
        function switchBattingTeam() {
            if (matchState === 'completed' || matchState === 'cancelled') {
                showMessageBox('Match is completed or cancelled. Start a new match or restart.', 'error');
                return;
            }

            // Save current batsmen's state before switching
            if (currentBattingTeam) {
                // currentStrikerIndex and currentNonStrikerIndex already refer to original players array
                // No need to re-assign values from dropdowns as they are already updated by their change listeners
            }

            // Determine the next batting and bowling teams
            const nextBattingTeam = (currentBattingTeam === team1) ? team2 : team1;
            const nextBowlingTeam = (currentBattingTeam === team1) ? team1 : team2;

            currentBattingTeam = nextBattingTeam;
            currentBowlingTeam = nextBowlingTeam;

            // Reset current bowler for the new bowling team
            currentBowlerIndex = -1;
            lastCompletedBowlerIndex = -1; // Reset for new innings

            // Set initial batsmen for the new batting team from their playing XI
            const nextBattingXI = getPlayingXIPlayers(currentBattingTeam);
            let nextBatsmanIndex = -1;
            let nextNonStrikerIndex = -1;

            // Find first two available players from the playing XI who are NOT out
            const availableXIPlayers = nextBattingXI.filter(p => !p.isOut);

            if (availableXIPlayers.length >= 2) {
                nextBatsmanIndex = currentBattingTeam.players.findIndex(p => p.name === availableXIPlayers[0].name);
                nextNonStrikerIndex = currentBattingTeam.players.findIndex(p => p.name === availableXIPlayers[1].name);
            } else if (availableXIPlayers.length === 1) {
                nextBatsmanIndex = currentBattingTeam.players.findIndex(p => p.name === availableXIPlayers[0].name);
                nextNonStrikerIndex = -1;
            } else {
                nextBatsmanIndex = -1;
                nextNonStrikerIndex = -1;
            }

            currentBattingTeam.currentStrikerIndex = nextBatsmanIndex;
            currentBattingTeam.currentNonStrikerIndex = nextNonStrikerIndex;

            currentPartnershipRuns = 0; // Reset partnership when switching batting teams
            isFreeHit = false; // Reset free hit on innings switch

            showMessageBox(`Switched to ${currentBattingTeam.name} batting!`, 'success');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to declare the winner and Man of the Match
        async function declareWinner(status, reason = null) { // Added status parameter and new reason parameter
            matchState = status; // Set matchState to 'completed' or 'cancelled'
            let resultMessage = '';

            // Determine which team batted first and which batted second
            const firstBattingTeam = (firstInningsTotalRuns === team1.runs) ? team1 : team2;
            const secondBattingTeam = (firstInningsTotalRuns === team1.runs) ? team2 : team1;

            if (status === 'Cancelled') {
                cancellationReason = reason; // Store the reason
                resultMessage = `Match Cancelled! Reason: ${cancellationReason}`; // Now explicitly setting the message for cancelled matches
            } else { // status === 'Completed'
                cancellationReason = ''; // Clear cancellation reason for completed matches
                const targetChased = secondBattingTeam.runs > firstInningsTotalRuns;

                if (targetChased) {
                    resultMessage = `${secondBattingTeam.name} wins by ${getPlayingXIPlayers(secondBattingTeam).length - 1 - secondBattingTeam.wickets} wickets!`; // Use playing XI length
                } else if (firstInningsTotalRuns > secondBattingTeam.runs) {
                    resultMessage = `${firstBattingTeam.name} wins by ${firstInningsTotalRuns - secondBattingTeam.runs} runs!`;
                } else {
                    resultMessage = `Match Drawn!`;
                }
            }


            // Determine Man of the Match (only for completed matches)
            const motmPlayer = (status === 'Completed') ? determineManOfTheMatch() : null;
            const motmName = motmPlayer ? motmPlayer.name : 'Not Available As Match ' + status; // Use 'status' directly

            // Save match details to localStorage immediately
            saveMatchDetailsLocal(resultMessage, motmName, status, cancellationReason); // Pass status and reason to save function
            saveCurrentMatchStateToLocal(); // Save final state to local storage

            // Immediately show the match result (winner and difference)
            matchResultMessageText.textContent = resultMessage; // Update only the text span
            
            // Show all summary elements
            matchResultDisplay.classList.remove('hidden');
            manOfTheMatchDisplay.classList.remove('hidden');
            manOfTheMatchPlayer.textContent = motmName; // Set Man of the Match player
            finalScorecardsSection.classList.remove('hidden');
            renderFinalScorecards(); // Render the final scorecards

            // Hide live score elements and show summary navigation
            currentBattingTeamContainer.classList.add('hidden');
            oversRemainingContainer.classList.add('hidden');
            tossInfoDisplay.classList.add('hidden');
            currentOverInfoPanel.classList.add('hidden');
            partnershipInfoPanel.classList.add('hidden');
            playerSelection.classList.add('hidden');
            scoreControls.classList.add('hidden');
            liveScorePanel.classList.add('hidden');
            liveScorecardsSection.classList.add('hidden');
            liveFOWSection.classList.add('hidden');

            restartMatchBtn.classList.remove('hidden'); // Show restart button
            newMatchBtn.classList.remove('hidden'); // Show new match button
            backBtnMatchSummary.classList.remove('hidden'); // Show back to summary button
            cancelMatchBtn.classList.add('hidden'); // Hide cancel button

            showMessageBox(`Match ${status.toLowerCase()}! Full summary displayed.`, 'success');
            console.log(`declareWinner(): Match ${status.toLowerCase()}. Summary displayed.`);

            // Disable score controls
            Array.from(scoreControls.children).forEach(button => button.disabled = true);
            strikerSelect.disabled = true;
            nonStrikerSelect.disabled = true;
            bowlerSelect.disabled = true;

            updateScoreboardDisplay(); // Update scoreboard display to reflect final state (this will hide the info boxes)
        }

        // Function to determine Man of the Match based on a simple heuristic
        function determineManOfTheMatch() {
            // Only consider players who were part of the playing XI
            let allPlayingXIPlayers = [...getPlayingXIPlayers(team1), ...getPlayingXIPlayers(team2)];
            let manOfTheMatch = null;
            let highestScore = -Infinity; // Initialize with negative infinity to ensure any valid score is higher

            allPlayingXIPlayers.forEach(player => {
                // Heuristic: Runs are highly valued, wickets are highly valued, low runs conceded are good.
                // Adjust weights as desired for different player types.
                let performanceScore = (player.runsScored * 2) + (player.wicketsTaken * 15) - (player.runsConceded * 0.5);

                // Add a small bonus for participation (e.g., if they faced balls or bowled)
                if (player.ballsFaced > 0 || player.ballsBowled > 0) {
                    performanceScore += 1;
                }
                
                // Prioritize players who actually contributed (e.g., non-zero runs or wickets)
                if (player.runsScored === 0 && player.wicketsTaken === 0 && player.wides === 0 && player.noBalls === 0 && player.ballsFaced === 0 && player.ballsBowled === 0) {
                    performanceScore = -Infinity; // Penalize players with absolutely no contribution
                }


                if (performanceScore > highestScore) {
                    highestScore = performanceScore;
                    manOfTheMatch = player;
                }
            });

            return manOfTheMatch;
        }


        // Function to undo the last action
        function undoLastAction() {
            if (!lastAction) {
                showMessageBox('No action to undo.', 'error');
                return;
            }

            const targetTeam = lastAction.team === 'team1' ? team1 : team2;
            // Determine the bowling team based on the current batting team (for extras/bowler stats)
            // This needs to be the team that was bowling when the action happened, not necessarily the currentBowlingTeam
            const bowlingTeamForUndo = (targetTeam === team1) ? team2 : team1;
            const currentBowler = bowlingTeamForUndo.players[lastAction.bowlerIndex];

            // Revert partnership runs and free hit state first
            currentPartnershipRuns = lastAction.prevPartnershipRuns;
            isFreeHit = lastAction.prevIsFreeHit;

            switch (lastAction.type) {
                case 'run':
                    const strikerForRun = targetTeam.players[lastAction.strikerIndex];
                    strikerForRun.runsScored -= lastAction.runs;
                    strikerForRun.ballsFaced--;
                    targetTeam.runs -= lastAction.runs;
                    currentBowler.runsConceded -= lastAction.runs;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    break;
                case 'wicket':
                    const batsmanOut = targetTeam.players[lastAction.batsmanOutIndex];
                    batsmanOut.isOut = false;
                    targetTeam.wickets--;
                    if (lastAction.dismissalType !== 'Run Out' && lastAction.dismissalType !== 'Hit Wicket') {
                        currentBowler.wicketsTaken--;
                    }
                    batsmanOut.ballsFaced--;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    targetTeam.currentStrikerIndex = lastAction.previousStrikerIndex;
                    targetTeam.currentNonStrikerIndex = lastAction.previousNonStrikerIndex;
                    // Remove last fall of wicket entry
                    if (targetTeam.fallOfWickets.length > 0) {
                        targetTeam.fallOfWickets.pop(); // Remove the last wicket entry
                    }
                    break;
                case 'freeHitWicketAttempt':
                    // No changes to runs/wickets, just ball counts
                    const strikerForFreeHit = targetTeam.players[lastAction.strikerIndex];
                    strikerForFreeHit.ballsFaced--;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    break;
                case 'ball':
                    const strikerForBall = targetTeam.players[lastAction.strikerIndex];
                    strikerForBall.ballsFaced--;
                    currentBowler.ballsBowled--;
                    targetTeam.balls--;
                    break;
                case 'wide':
                    // Revert total runs added for the wide
                    targetTeam.runs -= lastAction.totalRunsAdded;
                    targetTeam.totalWides -= 1;
                    currentBowler.runsConceded -= lastAction.totalRunsAdded;
                    currentBowler.wides -= 1;
                    break;
                case 'noBall':
                    // Revert total runs added for the no ball
                    targetTeam.runs -= lastAction.totalRunsAdded;
                    targetTeam.totalNoBalls -= 1;
                    currentBowler.runsConceded -= lastAction.totalRunsAdded;
                    currentBowler.noBalls -= 1;
                    break;
                case 'bye':
                    targetTeam.runs -= 1;
                    targetTeam.totalByes -= 1;
                    targetTeam.balls--;
                    currentBowler.ballsBowled--;
                    break;
                case 'legBye':
                    targetTeam.runs -= 1;
                    targetTeam.totalLegByes -= 1;
                    targetTeam.balls--;
                    currentBowler.ballsBowled--;
                    break;
            }

            // If the last action involved an automatic strike switch, reverse it
            if (lastAction.wasStrikeSwitched) {
                switchStrike(true);
            }

            // Adjust overs if balls go negative or cross over boundary
            if (targetTeam.balls < 0) {
                targetTeam.overs--;
                targetTeam.balls += 6;
            }
            if (currentBowler.ballsBowled < 0) {
                currentBowler.oversBowled--;
                currentBowler.ballsBowled += 6;
            }

            // If undoing an action that was the first ball of an over, and a bowler was previously restricted,
            // reinstate that restriction. This is crucial for the bowler re-selection fix.
            // This logic is complex and might need more robust state management for `lastCompletedBowlerIndex`
            // if multiple undo operations are expected to cross over boundaries. For a single undo,
            // we can try to infer.
            // For now, let's assume `lastCompletedBowlerIndex` is only set on over completion and cleared on first ball.
            // If we undo the first ball, the restriction should conceptually return.
            // This is a tricky edge case for `undo`. For simplicity, we'll keep `lastCompletedBowlerIndex` as is,
            // and the `populatePlayerDropdowns` will handle disabling based on `currentBattingTeam.balls === 0`.
            // The main fix for re-selection is in the `bowlerSelect.addEventListener`.


            lastAction = null; // Clear last action after undo
            showMessageBox('Last action undone.', 'info');
            updateScoreboardDisplay();
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }

        // Function to save current match state to local storage
        function saveCurrentMatchStateToLocal() {
            try {
                const currentMatchState = {
                    team1: team1,
                    team2: team2,
                    totalOversPerInnings: totalOversPerInnings,
                    matchState: matchState,
                    firstInningsTotalRuns: firstInningsTotalRuns,
                    currentBattingTeamName: currentBattingTeam ? currentBattingTeam.name : null,
                    currentBowlingTeamName: currentBowlingTeam ? currentBowlingTeam.name : null,
                    currentBowlerIndex: currentBowlerIndex,
                    currentStrikerIndex: currentBattingTeam ? currentBattingTeam.currentStrikerIndex : -1,
                    currentNonStrikerIndex: currentBattingTeam ? currentBattingTeam.currentNonStrikerIndex : -1,
                    currentPartnershipRuns: currentPartnershipRuns,
                    isFreeHit: isFreeHit, // Save free hit state
                    lastCompletedBowlerIndex: lastCompletedBowlerIndex, // Save last completed bowler
                    matchDate: document.getElementById('matchDate').value,
                    matchTime: document.getElementById('matchTime').value,
                    tossWinnerName: tossWinnerName, // NEW: Save toss winner
                    tossDecision: tossDecision, // NEW: Save toss decision
                    cancellationReason: cancellationReason // NEW: Save cancellation reason
                };
                localStorage.setItem('currentCricketMatch', JSON.stringify(currentMatchState));
                console.log("Current match state saved to local storage.");
            }
            catch (e) {
                console.error("Error saving current match state to local storage: ", e);
                showMessageBox('Failed to save current match state locally.', 'error');
            }
        }

        // Function to load current match state from local storage
        function loadCurrentMatchStateFromLocal() {
            try {
                const storedState = localStorage.getItem('currentCricketMatch');
                if (storedState) {
                    const loadedState = JSON.parse(storedState);
                    team1 = loadedState.team1;
                    team2 = loadedState.team2;
                    totalOversPerInnings = loadedState.totalOversPerInnings;
                    matchState = loadedState.matchState;
                    firstInningsTotalRuns = loadedState.firstInningsTotalRuns;
                    currentPartnershipRuns = loadedState.currentPartnershipRuns;
                    isFreeHit = loadedState.isFreeHit || false; // Load free hit state, default to false
                    lastCompletedBowlerIndex = loadedState.lastCompletedBowlerIndex || -1; // Load last completed bowler
                    tossWinnerName = loadedState.tossWinnerName || ''; // NEW: Load toss winner
                    tossDecision = loadedState.tossDecision || ''; // NEW: Load toss decision
                    cancellationReason = loadedState.cancellationReason || ''; // NEW: Load cancellation reason

                    // Re-establish object references for currentBattingTeam and currentBowlingTeam
                    if (loadedState.currentBattingTeamName === team1.name) {
                        currentBattingTeam = team1;
                        currentBowlingTeam = team2;
                    } else if (loadedState.currentBattingTeamName === team2.name) {
                        currentBattingTeam = team2;
                        currentBowlingTeam = team1;
                    } else {
                        currentBattingTeam = null;
                        currentBowlingTeam = null;
                    }

                    currentBowlerIndex = loadedState.currentBowlerIndex;
                    if (currentBattingTeam) {
                        currentBattingTeam.currentStrikerIndex = loadedState.currentStrikerIndex;
                        currentBattingTeam.currentNonStrikerIndex = loadedState.currentNonStrikerIndex;
                    }
                    
                    // Restore date and time inputs
                    document.getElementById('matchDate').value = loadedState.matchDate || '';
                    document.getElementById('matchTime').value = loadedState.matchTime || '';
                    document.getElementById('totalOvers').value = loadedState.totalOversPerInnings || '';
                    document.getElementById('team1Name').value = loadedState.team1.name || '';
                    document.getElementById('team2Name').value = loadedState.team2.name || '';
                    document.getElementById('team1Players').value = loadedState.team1.players.map(p => p.name).join('\n') || '';
                    document.getElementById('team2Players').value = loadedState.team2.players.map(p => p.name).join('\n') || '';

                    updateUIForMatchState(); // Show appropriate section based on loaded match state
                    // showMessageBox('Match state loaded from local storage.', 'info'); // Removed this message
                } else {
                    console.log("No previous match state found in local storage. Starting new registration.");
                    newMatch(); // Start a fresh match if no state found
                }
            } catch (e) {
                console.error("Error loading current match state from local storage: ", e);
                showMessageBox('Failed to load previous match state. Starting a new match.', 'error');
                newMatch(); // Ensure the UI is in a consistent state even after error
            }
        }


        // Function to reset the match to registration state
        function newMatch() {
            // Clear current match state from local storage
            localStorage.removeItem('currentCricketMatch');

            // Reset game state
            team1 = { name: '', players: [], captainName: '', wicketKeeperName: '', playing11Names: [], runs: 0, wickets: 0, overs: 0, balls: 0, totalWides: 0, totalNoBalls: 0, totalByes: 0, totalLegByes: 0, currentStrikerIndex: -1, currentNonStrikerIndex: -1, fallOfWickets: [] };
            team2 = { name: '', players: [], captainName: '', wicketKeeperName: '', playing11Names: [], runs: 0, wickets: 0, overs: 0, balls: 0, totalWides: 0, totalNoBalls: 0, totalByes: 0, totalLegByes: 0, currentStrikerIndex: -1, currentNonStrikerIndex: -1, fallOfWickets: [] };
            currentBattingTeam = null;
            currentBowlingTeam = null;
            currentBowlerIndex = -1;
            totalOversPerInnings = 0;
            matchState = 'registration';
            firstInningsTotalRuns = 0;
            lastAction = null;
            currentPartnershipRuns = 0; // Reset partnership for new match
            isFreeHit = false; // Reset free hit for new match
            lastCompletedBowlerIndex = -1; // Reset last completed bowler for new match
            tossWinnerName = ''; // NEW: Reset toss winner
            tossDecision = ''; // NEW: Reset toss decision
            cancellationReason = ''; // NEW: Reset cancellation reason

            // Clear form fields
            teamRegistrationForm.reset();
            registerTeamsBtn.textContent = 'Register Teams'; // Reset button text

            // Clear scorecards
            liveBatsmanScorecardTable.innerHTML = '';
            liveBowlerScorecardTable.innerHTML = '';
            liveFallOfWicketsList.innerHTML = '';
            liveBatsmanScorecardTeamName.textContent = '';
            liveBowlerScorecardTeamName.textContent = '';
            liveFowTeamName.textContent = '';

            finalTeam1BatsmanScorecardTable.innerHTML = '';
            finalTeam1BowlerScorecardTable.innerHTML = '';
            finalTeam1FOWList.innerHTML = '';
            finalTeam2BatsmanScorecardTable.innerHTML = '';
            finalTeam2BowlerScorecardTable.innerHTML = '';
            finalTeam2FOWList.innerHTML = '';
            finalTeam1NameDisplay.textContent = '';
            finalTeam2NameDisplay.textContent = '';

            pastMatchesList.innerHTML = ''; // Clear past matches list

            // Enable score controls and player selectors
            Array.from(scoreControls.children).forEach(button => button.disabled = false);
            strikerSelect.disabled = false;
            nonStrikerSelect.disabled = false;
            bowlerSelect.disabled = false;
            populatePlayerDropdowns(); // Clear dropdowns

            updateUIForMatchState(); // Show registration section and handle button visibility
            // showMessageBox('New match started! Please register teams.', 'success'); // Removed this message

            loadPastMatchesLocal(); // Reload past matches after a new match is started
        }

        // NEW: Function to restart the current match with same teams and toss
        function restartCurrentMatch() {
            // Reset core match stats for both teams
            [team1, team2].forEach(team => {
                team.runs = 0;
                team.wickets = 0;
                team.overs = 0;
                team.balls = 0;
                team.totalWides = 0;
                team.totalNoBalls = 0;
                team.totalByes = 0;
                team.totalLegByes = 0;
                team.fallOfWickets = [];

                // Reset player stats for all registered players
                team.players.forEach(player => {
                    player.runsScored = 0;
                    player.ballsFaced = 0;
                    player.isOut = false;
                    player.wicketsTaken = 0;
                    player.runsConceded = 0;
                    player.ballsBowled = 0;
                    player.wides = 0;
                    player.noBalls = 0;
                    player.oversBowled = 0;
                });
                // playing11Names should remain as selected
            });

            firstInningsTotalRuns = 0;
            lastAction = null;
            currentPartnershipRuns = 0;
            isFreeHit = false;
            lastCompletedBowlerIndex = -1;
            cancellationReason = ''; // Reset cancellation reason on restart

            // Re-establish currentBattingTeam and currentBowlingTeam based on original toss
            // This logic needs to mirror the toss decision in proceedToMatchReadyBtn
            let tempTeam1 = team1;
            let tempTeam2 = team2;

            if (tossWinnerName === tempTeam1.name) {
                if (tossDecision === 'bat') {
                    currentBattingTeam = tempTeam1;
                    currentBowlingTeam = tempTeam2;
                } else { // bowl
                    currentBattingTeam = tempTeam2;
                    currentBowlingTeam = tempTeam1;
                }
            } else { // team2 won toss
                if (tossDecision === 'bat') {
                    currentBattingTeam = tempTeam2;
                    currentBowlingTeam = tempTeam1;
                } else { // bowl
                    currentBattingTeam = tempTeam1;
                    currentBowlingTeam = tempTeam2;
                }
            }

            // Set initial batsmen for the current batting team from their playing XI
            const nextBattingXI = getPlayingXIPlayers(currentBattingTeam);
            if (nextBattingXI.length >= 2) {
                currentBattingTeam.currentStrikerIndex = currentBattingTeam.players.findIndex(p => p.name === nextBattingXI[0].name);
                currentBattingTeam.currentNonStrikerIndex = currentBattingTeam.players.findIndex(p => p.name === nextBattingXI[1].name);
            } else if (nextBattingXI.length === 1) {
                currentBattingTeam.currentStrikerIndex = currentBattingTeam.players.findIndex(p => p.name === nextBattingXI[0].name);
                currentBattingTeam.currentNonStrikerIndex = -1;
            } else {
                showMessageBox(`${currentBattingTeam.name} needs at least one player in Playing XI to start.`, 'error');
                return;
            }
            currentBowlerIndex = -1; // Reset bowler for new innings

            matchState = 'innings1'; // Set match state back to first innings

            // Clear live scorecards
            liveBatsmanScorecardTable.innerHTML = '';
            liveBowlerScorecardTable.innerHTML = '';
            liveFallOfWicketsList.innerHTML = '';

            // Ensure controls are re-enabled
            Array.from(scoreControls.children).forEach(button => button.disabled = false);
            strikerSelect.disabled = false;
            nonStrikerSelect.disabled = false;
            bowlerSelect.disabled = false;

            updateUIForMatchState(); // Show scoreboard and handle button visibility
            saveCurrentMatchStateToLocal();
            showMessageBox('Match restarted with same teams and Playing XI!', 'success');
        }


        // Function to render a batsman scorecard for a given team and table element
        function renderBatsmanScorecard(team, targetTable, teamNameElement, isLive = false) {
            targetTable.innerHTML = ''; // Clear previous rows
            if (teamNameElement) teamNameElement.textContent = team ? team.name : '';

            if (team) {
                // Filter players to show only those in the playing XI
                const playersToDisplay = team.players.filter(p => team.playing11Names.includes(p.name));

                playersToDisplay.forEach((player) => {
                    const row = targetTable.insertRow();
                    const nameCell = row.insertCell();
                    const runsCell = row.insertCell();
                    const ballsCell = row.insertCell();
                    const strikeRateCell = row.insertCell(); // New cell for Strike Rate
                    const statusCell = row.insertCell();

                    nameCell.textContent = player.name;
                    runsCell.textContent = player.runsScored;
                    ballsCell.textContent = player.ballsFaced;

                    // Calculate Strike Rate: (Runs / Balls Faced) * 100
                    const strikeRate = player.ballsFaced > 0 ? ((player.runsScored / player.ballsFaced) * 100).toFixed(2) : '0.00';
                    strikeRateCell.textContent = strikeRate;
                    
                    // Determine status based on context (live vs. final scorecard)
                    if (isLive) {
                        const originalPlayerIndex = team.players.findIndex(p => p.name === player.name);
                        statusCell.textContent = player.isOut ? `Out (${team.fallOfWickets.find(fow => fow.batsman === player.name)?.dismissalType || 'N/A'})` : (originalPlayerIndex === team.currentStrikerIndex ? 'Batting (Striker)' : (originalPlayerIndex === team.currentNonStrikerIndex ? 'Batting (Non-Striker)' : 'Yet to Bat'));
                        // Highlight current batsmen only in live scorecard
                        if (originalPlayerIndex === team.currentStrikerIndex || originalPlayerIndex === team.currentNonStrikerIndex) {
                            row.classList.add('bg-yellow-100');
                        }
                    } else {
                        statusCell.textContent = player.isOut ? `Out (${team.fallOfWickets.find(fow => fow.batsman === player.name)?.dismissalType || 'N/A'})` : 'Not Out';
                    }

                    runsCell.classList.add('text-right');
                    ballsCell.classList.add('text-right');
                    strikeRateCell.classList.add('text-right'); // Align Strike Rate to right
                });
            }
        }

        // Function to render a bowler scorecard for a given team and table element
        function renderBowlerScorecard(team, targetTable, teamNameElement, isLive = false) {
            targetTable.innerHTML = ''; // Clear previous rows
            if (teamNameElement) teamNameElement.textContent = team ? team.name : '';

            if (team) {
                // Filter players to show only those in the playing XI
                const playersToDisplay = team.players.filter(p => team.playing11Names.includes(p.name));

                playersToDisplay.forEach((player) => {
                    // Only show bowlers who have bowled at least one ball (including extras) or taken a wicket
                    if (player.ballsBowled > 0 || player.wicketsTaken > 0 || player.wides > 0 || player.noBalls > 0) {
                        const row = targetTable.insertRow();
                        const nameCell = row.insertCell();
                        const oversCell = row.insertCell();
                        const runsCell = row.insertCell();
                        const wicketsCell = row.insertCell();
                        const widesCell = row.insertCell();
                        const noBallsCell = row.insertCell();
                        const economyCell = row.insertCell(); // New cell for Economy

                        nameCell.textContent = player.name;
                        oversCell.textContent = `${player.oversBowled}.${player.ballsBowled % 6}`;
                        runsCell.textContent = player.runsConceded;
                        wicketsCell.textContent = player.wicketsTaken;
                        widesCell.textContent = player.wides;
                        noBallsCell.textContent = player.noBalls;

                        // Calculate Economy: Runs Conceded / Total Overs Bowled (including partial overs)
                        const totalBallsBowled = (player.oversBowled * 6) + player.ballsBowled;
                        const economy = totalBallsBowled > 0 ? ((player.runsConceded / totalBallsBowled) * 6).toFixed(2) : '0.00';
                        economyCell.textContent = economy;

                        oversCell.classList.add('text-right');
                        runsCell.classList.add('text-right');
                        wicketsCell.classList.add('text-right');
                        widesCell.classList.add('text-right');
                        noBallsCell.classList.add('text-right');
                        economyCell.classList.add('text-right'); // Align Economy to right

                        // Highlight current bowler only in live scorecard
                        if (isLive) {
                            const originalPlayerIndex = team.players.findIndex(p => p.name === player.name);
                            if (originalPlayerIndex === currentBowlerIndex) {
                                row.classList.add('bg-green-100');
                            }
                        }
                    }
                });
            }
        }

        // Function to render fall of wickets for a given team and list element
        function renderFallOfWickets(team, targetList, teamNameElement) {
            targetList.innerHTML = ''; // Clear previous entries
            if (teamNameElement) teamNameElement.textContent = team ? team.name : '';

            if (team && team.fallOfWickets.length > 0) {
                team.fallOfWickets.forEach(fow => {
                    const listItem = document.createElement('li');
                    let fowText = `${fow.batsman} out (${fow.dismissalType})`;
                    if (fow.fielder) { // Include fielder if present
                        fowText += ` by ${fow.fielder}`;
                    }
                    fowText += ` at ${fow.score} in ${fow.over} overs`;
                    listItem.textContent = fowText;
                    targetList.appendChild(listItem);
                });
            } else {
                const listItem = document.createElement('li');
                    listItem.textContent = 'No wickets yet.';
                    targetList.appendChild(listItem);
            }
        }

        // Function to render all final scorecards after the match ends
        function renderFinalScorecards() {
            // Retrieve the last saved match data to ensure we display the correct summary
            const storedMatches = JSON.parse(localStorage.getItem('cricketMatches')) || [];
            const lastMatch = storedMatches.length > 0 ? storedMatches[0] : null;

            if (!lastMatch) {
                console.warn("No last match data found to render final scorecards.");
                return;
            }

            finalTeam1NameDisplay.textContent = lastMatch.team1.name;
            finalTeam2NameDisplay.textContent = lastMatch.team2.name;

            // Use the data from lastMatch for rendering, ensuring only playing XI are shown
            const team1ForFinal = { ...lastMatch.team1, players: lastMatch.team1.players.filter(p => lastMatch.team1.playing11Names.includes(p.name)) };
            const team2ForFinal = { ...lastMatch.team2, players: lastMatch.team2.players.filter(p => lastMatch.team2.playing11Names.includes(p.name)) };


            renderBatsmanScorecard(team1ForFinal, finalTeam1BatsmanScorecardTable);
            renderBowlerScorecard(team2ForFinal, finalTeam1BowlerScorecardTable); // Team 2 bowled to Team 1
            renderFallOfWickets(team1ForFinal, finalTeam1FOWList);

            renderBatsmanScorecard(team2ForFinal, finalTeam2BatsmanScorecardTable);
            renderBowlerScorecard(team1ForFinal, finalTeam2BowlerScorecardTable); // Team 1 bowled to Team 2
            renderFallOfWickets(team2ForFinal, finalTeam2FOWList);

            // Set result and Man of the Match from the saved data
            manOfTheMatchPlayer.textContent = lastMatch.manOfTheMatch;
            matchResultMessageText.textContent = lastMatch.result; // Ensure message is set
            
            matchResultDisplay.classList.remove('hidden');
            manOfTheMatchDisplay.classList.remove('hidden');
            finalScorecardsSection.classList.remove('hidden');
        }

        // Function to save match details to localStorage
        function saveMatchDetailsLocal(resultMessage, manOfTheMatchName, status, cancellationReason = null) { // Added status parameter and cancellationReason
            try {
                // Get existing matches or initialize an empty array
                const existingMatches = JSON.parse(localStorage.getItem('cricketMatches')) || [];

                const matchData = {
                    timestamp: new Date().toISOString(), // Store as ISO string for easy parsing
                    matchDate: document.getElementById('matchDate').value, // Get match date
                    matchTime: document.getElementById('matchTime').value, // Get match time
                    team1: {
                        name: team1.name,
                        captainName: team1.captainName, // NEW
                        wicketKeeperName: team1.wicketKeeperName, // NEW
                        runs: team1.runs,
                        wickets: team1.wickets,
                        overs: team1.overs,
                        balls: team1.balls,
                        totalExtras: team1.totalWides + team1.totalNoBalls + team1.totalByes + team1.totalLegByes,
                        players: team1.players.map(player => ({ // Store full player data
                            name: player.name,
                            runsScored: player.runsScored,
                            ballsFaced: player.ballsFaced,
                            isOut: player.isOut,
                            wicketsTaken: player.wicketsTaken,
                            runsConceded: player.runsConceded,
                            ballsBowled: player.ballsBowled,
                            wides: player.wides, // Keep original wides
                            noBalls: player.noBalls, // Keep original noBalls
                            oversBowled: player.oversBowled
                        })),
                        playing11Names: team1.playing11Names, // NEW: Save playing XI names
                        fallOfWickets: team1.fallOfWickets
                    },
                    team2: {
                        name: team2.name,
                        captainName: team2.captainName, // NEW
                        wicketKeeperName: team2.wicketKeeperName, // NEW
                        runs: team2.runs,
                        wickets: team2.wickets,
                        overs: team2.overs,
                        balls: team2.balls,
                        totalWides: team2.totalWides,
                        totalNoBalls: team2.totalNoBalls,
                        totalByes: team2.totalByes,
                        totalLegByes: team2.totalLegByes,
                        totalExtras: team2.totalWides + team2.totalNoBalls + team2.totalByes + team2.totalLegByes,
                        players: team2.players.map(player => ({ // Store full player data
                            name: player.name,
                            runsScored: player.runsScored,
                            ballsFaced: player.ballsFaced,
                            isOut: player.isOut,
                            wicketsTaken: player.wicketsTaken,
                            runsConceded: player.runsConceded,
                            ballsBowled: player.ballsBowled,
                            wides: player.wides, // Keep original wides
                            noBalls: player.noBalls, // Keep original noBalls
                            oversBowled: player.oversBowled
                        })),
                        playing11Names: team2.playing11Names, // NEW: Save playing XI names
                        fallOfWickets: team2.fallOfWickets
                    },
                    totalOversPerInnings: totalOversPerInnings,
                    firstInningsTotalRuns: firstInningsTotalRuns,
                    result: resultMessage,
                    manOfTheMatch: manOfTheMatchName,
                    tossWinnerName: tossWinnerName, // Save toss winner for historical record
                    tossDecision: tossDecision, // Save toss decision for historical record
                    status: status, // NEW: Save match status
                    cancellationReason: cancellationReason // NEW: Save cancellation reason
                };

                existingMatches.unshift(matchData); // Add new match to the beginning
                localStorage.setItem('cricketMatches', JSON.stringify(existingMatches));
                showMessageBox('Match details saved to local storage!', 'success');
                loadPastMatchesLocal(); // Reload past matches to include the newly saved one

            } catch (e) {
                console.error("Error saving match details to local storage: ", e);
                showMessageBox('Failed to save match details to local storage.', 'error');
            }
        }

        // Function to load and display past matches from localStorage
        function loadPastMatchesLocal() {
            pastMatchesList.innerHTML = ''; // Clear existing list

            try {
                const storedMatches = JSON.parse(localStorage.getItem('cricketMatches')) || [];

                if (storedMatches.length === 0) {
                    const listItem = document.createElement('li');
                    listItem.textContent = 'No past matches recorded yet.';
                    pastMatchesList.appendChild(listItem);
                    return;
                }

                storedMatches.forEach((match) => {
                    const listItem = document.createElement('li');
                    // Use matchDate and matchTime if available, otherwise fallback to timestamp
                    const displayDateTime = match.matchDate && match.matchTime
                        ? `${match.matchDate} at ${match.matchTime}`
                        : new Date(match.timestamp).toLocaleString();

                    // Include toss info if available
                    const tossInfo = match.tossWinnerName && match.tossDecision
                        ? `<p class="text-md text-gray-700 mb-2">${match.tossWinnerName} won the toss and chose to ${match.tossDecision} first.</p>`
                        : '';

                    // Determine status text and color
                    let statusLabel = '';
                    if (match.status === 'Cancelled') {
                        statusLabel = `<p class="text-md text-black mb-2">Status: Cancelled</p>`; // Black, not bold
                    } else {
                        statusLabel = `<p class="text-md text-black mb-2">Status: Completed</p>`; // Black, not bold
                    }

                    // Filter players for display in past match summary to show only playing XI
                    const team1PlayingXI = match.team1.players.filter(p => match.team1.playing11Names.includes(p.name));
                    const team2PlayingXI = match.team2.players.filter(p => match.team2.playing11Names.includes(p.name));


                    // Create detailed HTML for each past match
                    listItem.innerHTML = `
                        <h4 class="text-lg font-bold text-gray-800">${match.team1.name} vs ${match.team2.name}</h4>
                        <p class="text-md text-gray-700 mb-2">Date & Time: ${displayDateTime}</p>
                        <p class="text-md text-gray-700 mb-2">Team 1: C: ${match.team1.captainName || 'N/A'}, WK: ${match.team1.wicketKeeperName || 'N/A'}</p>
                        <p class="text-md text-gray-700 mb-2">Team 2: C: ${match.team2.captainName || 'N/A'}, WK: ${match.team2.wicketKeeperName || 'N/A'}</p>
                        ${tossInfo}
                        ${statusLabel} <!-- Display Status here -->
                        <p class="text-md text-gray-700 mb-2">${match.result}</p>
                        <p class="text-md text-gray-700 mb-2">Man of the Match: ${match.manOfTheMatch}</p>
                        <div class="past-match-details">
                            <div class="card">
                                <h5>${match.team1.name} Scorecard (Playing XI)</h5>
                                <p>Runs: ${match.team1.runs}/${match.team1.wickets} (${match.team1.overs}.${match.team1.balls} Overs)</p>
                                <p>Extras: ${match.team1.totalExtras}</p>
                                <h6>Batsmen:</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>R</th><th>B</th><th>SR</th><th>Status</th></tr></thead>
                                        <tbody>
                                            ${team1PlayingXI.map(p => {
                                                const sr = p.ballsFaced > 0 ? ((p.runsScored / p.ballsFaced) * 100).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.runsScored}</td><td class="text-right">${p.ballsFaced}</td><td class="text-right">${sr}</td><td>${p.isOut ? `Out (${match.team1.fallOfWickets.find(fow => fow.batsman === p.name)?.dismissalType || 'N/A'})` : 'Not Out'}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Bowlers (${match.team2.name} Playing XI):</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>O</th><th>R</th><th>W</th><th>WD</th><th>NB</th><th>Econ</th></tr></thead>
                                        <tbody>
                                            ${team2PlayingXI.filter(p => p.ballsBowled > 0 || p.wicketsTaken > 0 || p.wides > 0 || p.noBalls > 0).map(p => {
                                                const totalBallsBowled = (p.oversBowled * 6) + p.ballsBowled;
                                                const econ = totalBallsBowled > 0 ? ((p.runsConceded / totalBallsBowled) * 6).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.oversBowled}.${p.ballsBowled % 6}</td><td class="text-right">${p.runsConceded}</td><td class="text-right">${p.wicketsTaken}</td><td class="text-right">${p.wides}</td><td class="text-right">${p.noBalls}</td><td class="text-right">${econ}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Fall of Wickets:</h6>
                                <ul>
                                    ${match.team1.fallOfWickets.map(fow => {
                                        let fowText = `${fow.batsman} out (${fow.dismissalType})`;
                                        if (fow.fielder) {
                                            fowText += ` by ${fow.fielder}`;
                                        }
                                        fowText += ` at ${fow.score} in ${fow.over} overs`;
                                        return `<li>${fowText}</li>`;
                                    }).join('') || '<li>No wickets.</li>'}
                                </ul>
                            </div>
                            <div class="card">
                                <h5>${match.team2.name} Scorecard (Playing XI)</h5>
                                <p>Runs: ${match.team2.runs}/${match.team2.wickets} (${match.team2.overs}.${match.team2.balls} Overs)</p>
                                <p>Extras: ${match.team2.totalExtras}</p>
                                <h6>Batsmen:</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>R</th><th>B</th><th>SR</th><th>Status</th></tr></thead>
                                        <tbody>
                                            ${team2PlayingXI.map(p => {
                                                const sr = p.ballsFaced > 0 ? ((p.runsScored / p.ballsFaced) * 100).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.runsScored}</td><td class="text-right">${p.ballsFaced}</td><td class="text-right">${sr}</td><td>${p.isOut ? `Out (${match.team2.fallOfWickets.find(fow => fow.batsman === p.name)?.dismissalType || 'N/A'})` : 'Not Out'}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Bowlers (${match.team1.name} Playing XI):</h6>
                                <div class="overflow-x-auto">
                                    <table>
                                        <thead><tr><th>Name</th><th>O</th><th>R</th><th>W</th><th>WD</th><th>NB</th><th>Econ</th></tr></thead>
                                        <tbody>
                                            ${team1PlayingXI.filter(p => p.ballsBowled > 0 || p.wicketsTaken > 0 || p.wides > 0 || p.noBalls > 0).map(p => {
                                                const totalBallsBowled = (p.oversBowled * 6) + p.ballsBowled;
                                                const econ = totalBallsBowled > 0 ? ((p.runsConceded / totalBallsBowled) * 6).toFixed(2) : '0.00';
                                                return `<tr><td>${p.name}</td><td class="text-right">${p.oversBowled}.${p.ballsBowled % 6}</td><td class="text-right">${p.runsConceded}</td><td class="text-right">${p.wicketsTaken}</td><td class="text-right">${p.wides}</td><td class="text-right">${p.noBalls}</td><td class="text-right">${econ}</td></tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <h6>Fall of Wickets:</h6>
                                <ul>
                                    ${match.team2.fallOfWickets.map(fow => {
                                        let fowText = `${fow.batsman} out (${fow.dismissalType})`;
                                        if (fow.fielder) {
                                            fowText += ` by ${fow.fielder}`;
                                        }
                                        fowText += ` at ${fow.score} in ${fow.over} overs`;
                                        return `<li>${fowText}</li>`;
                                    }).join('') || '<li>No wickets.</li>'}
                                </ul>
                            </div>
                        </div>
                    `;
                    pastMatchesList.appendChild(listItem);
                });
            } catch (e) {
                console.error("Error loading documents from local storage: ", e);
                showMessageBox('Failed to load past match details from local storage.', 'error');
            }
        }

        // Function to clear all past matches from localStorage
        function clearAllPastMatches() {
            // Using a custom modal instead of alert/confirm
            showConfirmationModal('Are you sure you want to clear all past match data? This action cannot be undone.',
                () => {
                    localStorage.removeItem('cricketMatches');
                    pastMatchesList.innerHTML = '<li class="text-gray-600">No past matches recorded yet.</li>';
                    showMessageBox('All past match data cleared!', 'success');
                },
                () => {
                    // No message on cancel
                }
            );
        }

        // NEW: Function to populate toss dropdowns
        function populateTossDropdowns() {
            tossWinnerSelect.innerHTML = '<option value="">Select Winning Team</option>';
            const team1Option = document.createElement('option');
            team1Option.value = 'team1';
            team1Option.textContent = team1.name;
            tossWinnerSelect.appendChild(team1Option);

            const team2Option = document.createElement('option');
            team2Option.value = 'team2';
            team2Option.textContent = team2.name;
            tossWinnerSelect.appendChild(team2Option);

            // Restore selected values if loaded from state
            if (tossWinnerName) {
                tossWinnerSelect.value = tossWinnerName === team1.name ? 'team1' : 'team2';
            }
            if (tossDecision) {
                tossDecisionSelect.value = tossDecision;
            }
        }

        // NEW: Function to render Captain & Wicket Keeper selection dropdowns
        function renderCaptainWkSelection() {
            displayTeam1NameWk.textContent = team1.name;
            displayTeam2NameWk.textContent = team2.name;

            // Clear previous options
            team1CaptainSelect.innerHTML = '<option value="">Select Captain</option>';
            team1WkSelect.innerHTML = '<option value="">Select Wicket Keeper</option>';
            team2CaptainSelect.innerHTML = '<option value="">Select Captain</option>';
            team2WkSelect.innerHTML = '<option value="">Select Wicket Keeper</option>';

            // Populate dropdowns with players from each team's Playing XI
            const team1XI = getPlayingXIPlayers(team1);
            const team2XI = getPlayingXIPlayers(team2);

            team1XI.forEach(player => {
                const opt1C = document.createElement('option');
                opt1C.value = player.name;
                opt1C.textContent = player.name;
                team1CaptainSelect.appendChild(opt1C);

                const opt1Wk = document.createElement('option');
                opt1Wk.value = player.name;
                opt1Wk.textContent = player.name;
                team1WkSelect.appendChild(opt1Wk);
            });

            team2XI.forEach(player => {
                const opt2C = document.createElement('option');
                opt2C.value = player.name;
                opt2C.textContent = player.name;
                team2CaptainSelect.appendChild(opt2C);

                const opt2Wk = document.createElement('option');
                opt2Wk.value = player.name;
                opt2Wk.textContent = player.name;
                team2WkSelect.appendChild(opt2Wk);
            });

            // Set selected values if already stored
            if (team1.captainName) team1CaptainSelect.value = team1.captainName;
            if (team1.wicketKeeperName) team1WkSelect.value = team1.wicketKeeperName;
            if (team2.captainName) team2CaptainSelect.value = team2.captainName;
            if (team2.wicketKeeperName) team2WkSelect.value = team2.wicketKeeperName;
        }

        // NEW: Function to render Playing XI selection checkboxes
        function renderPlayingXISelection() {
            team1PlayersList.innerHTML = '';
            team2PlayersList.innerHTML = '';

            team1PlayingXITitle.innerHTML = `Team 1 Players <span id="team1PlayingXICounter" class="text-sm text-gray-500">(${team1.playing11Names.length}/11)</span>`;
            team2PlayingXITitle.innerHTML = `Team 2 Players <span id="team2PlayingXICounter" class="text-sm text-gray-500">(${team2.playing11Names.length}/11)</span>`;

            team1.players.forEach(player => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = player.name;
                checkbox.checked = team1.playing11Names.includes(player.name); // Pre-check if already in XI
                checkbox.addEventListener('change', () => updatePlayingXI(team1, checkbox.value, checkbox.checked));
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(player.name));
                team1PlayersList.appendChild(label);
            });

            team2.players.forEach(player => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = player.name;
                checkbox.checked = team2.playing11Names.includes(player.name); // Pre-check if already in XI
                checkbox.addEventListener('change', () => updatePlayingXI(team2, checkbox.value, checkbox.checked));
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(player.name));
                team2PlayersList.appendChild(label);
            });
        }

        // NEW: Function to update playing XI based on checkbox changes
        function updatePlayingXI(team, playerName, isChecked) {
            if (isChecked) {
                if (team.playing11Names.length < 11) {
                    team.playing11Names.push(playerName);
                } else {
                    showMessageBox(`You can only select 11 players for ${team.name}.`, 'error');
                    // Uncheck the box if already 11 players selected
                    const checkbox = team === team1 ? team1PlayersList.querySelector(`input[value="${playerName}"]`) : team2PlayersList.querySelector(`input[value="${playerName}"]`);
                    if (checkbox) checkbox.checked = false;
                }
            } else {
                team.playing11Names = team.playing11Names.filter(name => name !== playerName);
            }
            // Update the counter immediately
            if (team === team1) {
                document.getElementById('team1PlayingXICounter').textContent = `(${team.playing11Names.length}/11)`;
            } else {
                document.getElementById('team2PlayingXICounter').textContent = `(${team.playing11Names.length}/11)`;
            }
            saveCurrentMatchStateToLocal(); // Save changes to local storage
        }


        // Event listener for team registration form submission
        teamRegistrationForm.addEventListener('submit', async function(event) {
            event.preventDefault(); // Prevent default form submission

            try {
                // Get team names
                const team1Name = document.getElementById('team1Name').value.trim();
                const team2Name = document.getElementById('team2Name').value.trim();
                const oversInput = document.getElementById('totalOvers').value;
                const matchDate = document.getElementById('matchDate').value;
                const matchTime = document.getElementById('matchTime').value;


                // Get player lists and split by new line
                const team1PlayersRaw = document.getElementById('team1Players').value.trim();
                const team2PlayersRaw = document.getElementById('team2Players').value.trim();

                // Basic validation
                if (!team1Name || !team2Name || !oversInput || !matchDate || !matchTime) {
                    showMessageBox('Please fill in all required fields.', 'error');
                    return;
                }
                if (!team1PlayersRaw || !team2PlayersRaw) {
                    showMessageBox('Please enter players for both teams.', 'error');
                    return;
                }

                totalOversPerInnings = parseInt(oversInput, 10);
                if (isNaN(totalOversPerInnings) || totalOversPerInnings <= 0) {
                    showMessageBox('Please enter a valid number for total overs (greater than 0).', 'error');
                    return;
                }

                // Populate team objects and initialize player stats
                team1.name = team1Name;
                team1.players = team1PlayersRaw.split('\n').map(p => p.trim()).filter(p => p).map(name => ({
                    name: name,
                    runsScored: 0,
                    ballsFaced: 0,
                    isOut: false,
                    wicketsTaken: 0,
                    runsConceded: 0,
                    ballsBowled: 0,
                    wides: 0,
                    noBalls: 0,
                    oversBowled: 0 // Track full overs bowled by bowler
                }));
                // Preserve playing11Names if already set (e.g., if returning from XI selection)
                // If this is a fresh registration, it will be an empty array
                if (!team1.playing11Names || team1.playing11Names.length === 0) {
                    team1.playing11Names = [];
                }


                team2.name = team2Name;
                team2.players = team2PlayersRaw.split('\n').map(p => p.trim()).filter(p => p).map(name => ({
                    name: name,
                    runsScored: 0,
                    ballsFaced: 0,
                    isOut: false,
                    wicketsTaken: 0,
                    runsConceded: 0,
                    ballsBowled: 0,
                    wides: 0,
                    noBalls: 0,
                    oversBowled: 0
                }));
                // Preserve playing11Names if already set
                if (!team2.playing11Names || team2.playing11Names.length === 0) {
                    team2.playing11Names = [];
                }


                // Set match state to 'playing_xi_selection' after successful registration
                matchState = 'playing_xi_selection';

                updateUIForMatchState(); // Show playing XI selection section and handle button visibility
                showMessageBox('Teams registered! Now select your Playing XI.', 'success');
                saveCurrentMatchStateToLocal(); // Save current state after registration
            }
            catch (error) {
                console.error('Error registering teams:', error);
                showMessageBox('An error occurred during team registration. Please try again.', 'error');
            }
        });

        // NEW: Event listener for Confirm Playing XI button
        confirmPlayingXIBtn.addEventListener('click', () => {
            if (team1.players.length < 11 || team2.players.length < 11) {
                showMessageBox('Each team must have at least 11 registered players to select a Playing XI.', 'error');
                return;
            }
            if (team1.playing11Names.length !== 11 || team2.playing11Names.length !== 11) {
                showMessageBox('Please select exactly 11 players for both teams.', 'error');
                return;
            }

            matchState = 'captain_wk_selection'; // Move to Captain/WK selection

            updateUIForMatchState(); // Show Captain/WK selection section and handle button visibility
            showMessageBox('Playing XI confirmed! Now select your Captain and Wicket Keeper.', 'success');
            saveCurrentMatchStateToLocal();
        });

        // NEW: Event listener for Confirm Captain & WK button
        confirmCaptainWkBtn.addEventListener('click', () => {
            const team1Cap = team1CaptainSelect.value;
            const team1Wk = team1WkSelect.value;
            const team2Cap = team2CaptainSelect.value;
            const team2Wk = team2WkSelect.value;

            if (!team1Cap || !team1Wk || !team2Cap || !team2Wk) {
                showMessageBox('Please select a Captain and Wicket Keeper for both teams.', 'error');
                return;
            }
            if (team1Cap === team1Wk) {
                showMessageBox('Team 1 Captain and Wicket Keeper cannot be the same player.', 'error');
                return;
            }
            if (team2Cap === team2Wk) {
                showMessageBox('Team 2 Captain and Wicket Keeper cannot be the same player.', 'error');
                return;
            }

            // Ensure Captain and WK are part of the Playing XI
            if (!team1.playing11Names.includes(team1Cap) || !team1.playing11Names.includes(team1Wk)) {
                showMessageBox('Team 1 Captain and Wicket Keeper must be part of the Playing XI.', 'error');
                return;
            }
            if (!team2.playing11Names.includes(team2Cap) || !team2.playing11Names.includes(team2Wk)) {
                showMessageBox('Team 2 Captain and Wicket Keeper must be part of the Playing XI.', 'error');
                return;
            }

            team1.captainName = team1Cap;
            team1.wicketKeeperName = team1Wk;
            team2.captainName = team2Cap;
            team2.wicketKeeperName = team2Wk;

            matchState = 'toss'; // Move to toss after Captain/WK selection

            updateUIForMatchState(); // Show toss section and handle button visibility
            showMessageBox('Captain and Wicket Keeper confirmed! Now perform the toss.', 'success');
            saveCurrentMatchStateToLocal();
        });

        // Event listener for Proceed to Match Ready button (from Toss Section)
        proceedToMatchReadyBtn.addEventListener('click', () => {
            const selectedTossWinner = tossWinnerSelect.value;
            const selectedTossDecision = tossDecisionSelect.value;

            if (!selectedTossWinner || !selectedTossDecision) {
                showMessageBox('Please select both toss winner and their decision.', 'error');
                return;
            }

            tossWinnerName = (selectedTossWinner === 'team1') ? team1.name : team2.name;
            tossDecision = selectedTossDecision;

            // Determine initial batting and bowling teams based on toss
            if (selectedTossWinner === 'team1') {
                if (selectedTossDecision === 'bat') {
                    currentBattingTeam = team1;
                    currentBowlingTeam = team2;
                } else { // bowl
                    currentBattingTeam = team2;
                    currentBowlingTeam = team1;
                }
            } else { // team2 won toss
                if (selectedTossDecision === 'bat') {
                    currentBattingTeam = team2;
                    currentBowlingTeam = team1;
                } else { // bowl
                    currentBattingTeam = team1;
                    currentBowlingTeam = team2;
                }
            }

            matchState = 'teams_registered'; // Set match state to teams_registered after toss

            updateUIForMatchState(); // Show match ready section and handle button visibility
            registeredTeamsSummary.textContent = `${team1.name} (C: ${team1.captainName}, WK: ${team1.wicketKeeperName}) vs ${team2.name} (C: ${team2.captainName}, WK: ${team2.wicketKeeperName}) (${totalOversPerInnings} Overs per innings) on ${document.getElementById('matchDate').value} at ${document.getElementById('matchTime').value}. ${tossWinnerName} won the toss and chose to ${tossDecision} first.`;
            showMessageBox('Toss completed! Match ready to start.', 'success');
            saveCurrentMatchStateToLocal();
        });

        // NEW: Event listener for "Back" button from Playing XI Selection
        backBtnPlayingXI.addEventListener('click', () => {
            matchState = 'registration'; // Set match state back to registration
            updateUIForMatchState(); // Show registration section and handle button visibility
            // Re-populate the registration form fields with current data
            document.getElementById('team1Name').value = team1.name;
            document.getElementById('team1Players').value = team1.players.map(p => p.name).join('\n');
            document.getElementById('team2Name').value = team2.name;
            document.getElementById('team2Players').value = team2.players.map(p => p.name).join('\n');
            document.getElementById('totalOvers').value = totalOversPerInnings;
            document.getElementById('matchDate').value = document.getElementById('matchDate').value;
            document.getElementById('matchTime').value = document.getElementById('matchTime').value;

            // Change the button text
            registerTeamsBtn.textContent = 'Update Team Details';

            showMessageBox('Returned to Team Registration to edit player lists.', 'info');
            saveCurrentMatchStateToLocal();
        });

        // NEW: Event listener for "Back" button from Captain/WK Selection
        backBtnCaptainWk.addEventListener('click', () => {
            matchState = 'playing_xi_selection'; // Set match state back to Playing XI selection
            updateUIForMatchState(); // Show Playing XI section and handle button visibility
            renderPlayingXISelection(); // Re-render checkboxes
            showMessageBox('Returned to Playing XI selection.', 'info');
            saveCurrentMatchStateToLocal();
        });

        // NEW: Event listener for "Back" button from Toss Section
        backBtnToss.addEventListener('click', () => {
            matchState = 'captain_wk_selection'; // Set match state back to Captain/WK selection
            updateUIForMatchState(); // Show Captain/WK section and handle button visibility
            renderCaptainWkSelection(); // Re-render dropdowns
            showMessageBox('Returned to Captain & Wicket Keeper selection.', 'info');
            saveCurrentMatchStateToLocal();
        });

        // NEW: Event listener for "Back" button from Match Ready Section
        backBtnMatchReady.addEventListener('click', () => {
            matchState = 'toss'; // Set match state back to toss
            updateUIForMatchState(); // Show toss section and handle button visibility
            populateTossDropdowns(); // Re-populate toss dropdowns
            showMessageBox('Returned to Toss section.', 'info');
            saveCurrentMatchStateToLocal();
        });


        // Event listener for Start Match button
        startMatchBtn.addEventListener('click', async () => {
            if (matchState === 'teams_registered') {
                matchState = 'innings1'; // Set match state to first innings

                // Set initial batsmen for the current batting team (determined by toss) from their playing XI
                const battingXI = getPlayingXIPlayers(currentBattingTeam);
                if (battingXI.length >= 2) {
                    currentBattingTeam.currentStrikerIndex = currentBattingTeam.players.findIndex(p => p.name === battingXI[0].name);
                    currentBattingTeam.currentNonStrikerIndex = currentBattingTeam.players.findIndex(p => p.name === battingXI[1].name);
                } else if (battingXI.length === 1) {
                    currentBattingTeam.currentStrikerIndex = currentBattingTeam.players.findIndex(p => p.name === battingXI[0].name);
                    currentBattingTeam.currentNonStrikerIndex = -1;
                } else {
                    showMessageBox(`${currentBattingTeam.name} needs at least one player in Playing XI to start.`, 'error');
                    return;
                }

                updateUIForMatchState(); // Show scoreboard and handle button visibility
                showMessageBox('Match started!', 'success');
                saveCurrentMatchStateToLocal(); // Save initial match state to local storage
            } else {
                showMessageBox('Teams are not registered, toss is not completed, or Playing XI is not selected.', 'error');
            }
        });


        // Add event listeners for score control buttons
        add1RunBtn.addEventListener('click', () => addRuns(1));
        add2RunsBtn.addEventListener('click', () => addRuns(2));
        add4RunsBtn.addEventListener('click', () => addRuns(4));
        add6RunsBtn.addEventListener('click', () => addRuns(6));
        // New Wicket Buttons
        addCaughtBtn.addEventListener('click', () => addWicket('Caught'));
        addBowledLbwBtn.addEventListener('click', () => addWicket('Bowled/LBW'));
        addRunOutBtn.addEventListener('click', () => addWicket('Run Out'));
        addStumpedBtn.addEventListener('click', () => addWicket('Stumped'));
        addHitWicketBtn.addEventListener('click', () => addWicket('Hit Wicket'));
        addOtherWicketBtn.addEventListener('click', () => addWicket('Other'));

        addBallBtn.addEventListener('click', addBall);
        addWideBtn.addEventListener('click', addWide);
        addNoBallBtn.addEventListener('click', addNoBall);
        addByeBtn.addEventListener('click', addBye);
        addLegByeBtn.addEventListener('click', addLegBye);
        switchStrikeBtn.addEventListener('click', switchStrike);
        undoBtn.addEventListener('click', undoLastAction);
        switchTeamBtn.addEventListener('click', switchBattingTeam);
        newMatchBtn.addEventListener('click', () => {
            showConfirmationModal('Are you sure you want to start a new match? Current game progress will be lost if not saved.', newMatch, () => { /* do nothing */ });
        });
        clearPastMatchesBtn.addEventListener('click', clearAllPastMatches); // New button listener
        
        // Removed: endMatchBtn.addEventListener('click', ...); // This button is now removed

        // NEW: Restart Match button listener
        restartMatchBtn.addEventListener('click', () => {
            showConfirmationModal('Are you sure you want to restart the current match? All current progress will be lost.',
                () => {
                    restartCurrentMatch(); // Call new function to restart with same teams/toss
                },
                () => {
                    // No message on cancel
                }
            );
        });

        // NEW: Cancel Match button listener
        cancelMatchBtn.addEventListener('click', () => {
            // Show the cancellation reason modal first
            cancelReasonModal.classList.remove('hidden');
            // Reset dropdown to default
            cancellationReasonSelect.value = '';
        });

        // NEW: Confirm Cancellation Reason button listener
        confirmCancellationReasonBtn.addEventListener('click', () => {
            const selectedReason = cancellationReasonSelect.value;
            if (!selectedReason) {
                showMessageBox('Please select a cancellation reason.', 'error');
                return;
            }
            cancelReasonModal.classList.add('hidden'); // Hide the reason modal
            declareWinner('Cancelled', selectedReason); // Pass the selected reason
            // newMatch(); // Removed: Don't call newMatch here, let declareWinner handle UI
            showMessageBox('Match cancelled and saved to past matches.', 'success');
        });

        // NEW: Back from Cancel Reason button listener
        backFromCancelReasonBtn.addEventListener('click', () => {
            cancelReasonModal.classList.add('hidden'); // Just hide the modal
        });

        // NEW: Back button from Match Summary (Final Scorecards Section)
        backBtnMatchSummary.addEventListener('click', () => {
            matchState = 'past_matches'; // Set state to past matches
            updateUIForMatchState(); // Show past matches section and handle button visibility
            showMessageBox('Returned to Past Matches.', 'info');
        });

        // NEW: Reset All button listener (MOVED)
        resetAllBtn.addEventListener('click', () => {
            showConfirmationModal('Are you sure you want to reset all team and player data? This will start a completely new match registration.',
                () => {
                    newMatch(); // Reuse the newMatch function for a full reset
                    registerTeamsBtn.textContent = 'Register Teams'; // Ensure button text is reset
                    showMessageBox('All data reset. Please register new teams.', 'info');
                },
                () => {
                    // No message on cancel
                }
            );
        });


        // Event listeners for Developer Info page (NEW)
        developerInfoBtn.addEventListener('click', () => {
            matchState = 'developer_info'; // Set state to developer info
            updateUIForMatchState(); // Show developer info section and handle button visibility
        });

        backBtnDeveloperInfo.addEventListener('click', () => {
            // Determine which section to return to based on the current match state
            // This logic is now handled by updateUIForMatchState based on the previous matchState
            // We need a way to store the *previous* state before going to developer info.
            // For simplicity, let's assume it always returns to 'registration' or 'scoreboard' if active.
            // A more robust solution would involve pushing states onto a stack.
            // For now, let's just make it return to 'registration' unless a match is active.

            // A simple approach: if a match is active or completed, return to scoreboard, else to registration.
            if (matchState === 'innings1' || matchState === 'innings2' || matchState === 'completed' || matchState === 'cancelled') {
                matchState = 'scoreboard'; // Return to scoreboard
            } else {
                matchState = 'registration'; // Return to registration
            }
            updateUIForMatchState(); // Show appropriate section and handle button visibility
            showMessageBox('Returned to previous section.', 'info');
        });


        // Initial load of past matches and current match state when the page loads
        window.onload = () => {
            loadCurrentMatchStateFromLocal(); // Attempt to load current match state first
            loadPastMatchesLocal(); // Always load past matches on startup
        };
    </script>
</body>
</html>
